#!/usr/bin/env python

#
# Run the test suite, report failures
#
# To set command for running parallel jobs, define environment variable
# e.g. for bash
# export MPIRUN="mpirun -np"
# export MPIRUN="aprun -n"

from __future__ import print_function
import os
import sys
import time
import re
from boututils.run_wrapper import shell

# Check requirements

requirements_path = "../requirements"

# Get list of files in subdirectory, excluding common temporaries
requirements = [ x for x in os.listdir(requirements_path)
                 if not (("#" in x) or ("~" in x) or (x[0] == ".")) ]

print("======= Requirement checks ========")

requirement_dict = {}
for requirement in requirements:
    status,out = shell(os.path.join(requirements_path, requirement), pipe=True)
    requirement_dict[requirement] = (status == 0)
    print("{0} => {1}".format(requirement, (status == 0)))

# Now have dictionary of requirements, true/false.

def check_requirements(script):
    """Tests if the requirements of the given script (file name) are met.
    Returns the result (True/False) and the requirements expression.
    """

    with open(script, "r") as filein:
        contents = filein.read()
        
        # Find a string starting with '#requires"        
        match = re.search("\#requires(.*)", contents)
        if match:
            expr = match.groups()[0] # Expression to evaluate
            return eval(expr, requirement_dict), expr # requirements as global variables
        
    return True, "" # Default, if no requirements specified


##################################################################

# Get list of directories containing test cases
tests=[]
with open('test_suite_list') as testfile:
    for test in testfile:
        test=test.strip()
        if test.startswith("#"):
            pass
        elif test.startswith("!"):
            tests.append(test[1:])
        else:
            tests.append(test)

##################################################################

savepath = os.getcwd() # Save current working directory
npassed = 0
nfailed = 0
total = len(tests)
failed = []

start_time = time.time()

print("======= Starting {0} tests ========".format(savepath.split("/")[-1]))
print("Running {0} tests".format(total))

for t in tests:
    os.chdir(t)

    # Check requirements
    req_met, req_expr = check_requirements("./runtest")
    if not req_met:
        print("S - {0} - {1} => False".format(t, req_expr))
        sys.stdout.flush()
        os.chdir(savepath)
        continue
    
    start_time_ = time.time()
    # Run test, piping stdout so it is not sent to console
    status,out = shell("./runtest", pipe=True)

    if status != 0:
        print("F", end='') # No newline
        nfailed = nfailed + 1
        failed.append((t, out))
    else:
        # Passed
        print(".", end='') # No newline
        npassed = npassed + 1

    print(" %7.3f s - %s"%(time.time() - start_time_,t))
    sys.stdout.flush() # Make sure '.' or 'F' is flushed
    os.chdir(savepath)

elapsed_time = time.time() - start_time

print("\n")

if nfailed > 0:
    print("======= FAILURES ========")
    for test, output in failed:
        # Note: need Unicode string in case output contains unicode
        print(u"\n----- {0} -----\n{1}".format(test, output))

    print("======= {0} failed in {1:.2f} seconds ========".format(nfailed, elapsed_time))

    sys.exit(1)

else:
    print("======= All tests passed in {0:.2f} seconds =======".format(elapsed_time))
