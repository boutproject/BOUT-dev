#!/usr/bin/env python3
import boutcore as bc
import numpy as np
import sys

#requires boutcore
#requires not make

bc.init("-d data -q -q -q")
doPlot=0
for f in sys.argv[1:]:
    if f == '-p':
        doPlot += 1

def mget(f):
    return f[3,:,0].flatten()

if doPlot > 2:
    start=2
    mmax=4
else:
    start=9
    mmax=10

def plot(*args):
    import matplotlib.pyplot as plt
    def close_event():
        plt.close()
    fig=plt.figure()
    for f in args:
        pf = plt.plot
        if "log" in f:
            f.remove("log")
            pf=plt.loglog
        if isinstance(f[-1],str):
            pf(*f[:-1],label=f[-1])
        else:
            pf(*f)
        #plt.plot(mget(y),mget(f),'-o')
        #plt.plot(mget(y),fo,'x-')
        plt.legend()
    timer = fig.canvas.new_timer(interval = 4000)
    timer.add_callback(close_event)
    timer.start()
    plt.show()

def create(nx,low):
    udx=2*np.pi/nx
    if not low:
        ux=np.linspace(-1.5*udx,2*np.pi+1.5*udx,num=(nx+4))
    else:
        ux=np.linspace(-1*udx,2*np.pi+2*udx,num=(nx+4))
    nux = ux-.8*np.cos(ux)
    return nux

def integrate(dat,low):
    ret=np.zeros_like(dat)
    cur=-dat[0]
    cur-=dat[1]
    if low:
        for i in range(len(dat)):
            ret[i] = cur
            cur+=dat[i]
    else:
        for i in range(len(dat)):
            cur+=dat[i]/2
            ret[i] = cur
            cur+=dat[i]/2
    return ret


mesh_cache={}
def test(bdry, func, loc):
    print("Testing %s with %s at %s"%(bdry,func,loc),end=' ... ')
    errs=[]
    dy=[]

    for ny in np.logspace(start,mmax,num=mmax-start+1,base=2):
        global mesh_cache
        try:
            mesh=mesh_cache[ny]
        except KeyError:
            bc.setOption("mesh:ny","%d"%ny,force=True)
            bc.setOption("mesh:dy","(1+0.8*sin(y))/%d*2*pi"%ny,force=True)
            mesh=bc.Mesh(section="mesh")
            mesh_cache[ny]=mesh
        mdy = mesh.coordinates.dy.get()[3,:].flatten()
        y=integrate(mdy,loc == "YLOW")
        fd=func(y)
        f = bc.create3D("y",mesh,outloc=loc)
        fds= fd.reshape((1,int(ny)+4,1))
        for i in range(6):
            f[i,:,0] = fds

        fo=mget(f)
        opt=bc.Options("")

        myg=int(opt.get("mesh:myg",0))

        for i in range(myg):
            f[0, i  ,0]=-1
            f[0,-1-i,0]=-1

        f.applyBoundary(bdry)
        f=mget(f)
        if doPlot > 2:
            plot([y,f,"with bc"],[y,fo,"org"],[y,"numpy"],[integrate(mdy,loc == "YLOW"),"bc"])
        er=np.max(np.abs(f-fo))
        errs.append(er)
        dy.append(1./ny)

    errc=np.log(errs[-2]/errs[-1])
    difc=np.log(dy[-2]/dy[-1])
    conv=errc/difc
    success= order - .25 < conv < order + .25
    if doPlot > 1 or (not success and doPlot > 0):
        plot([dy,errs,"log","error vs spacing"])
    if success:
        print("Pass")
        return 0
    else:
        print("Failure: expected %d, got %g"%(order,conv))
        return 1



testdata=[
    ["dirichlet_nu_o4", np.sin, 5],
    ["dirichlet_nu_o3", np.sin, 3],
    ["dirichlet_nu_o2", np.sin, 3],
    ["neumann_nu_o2", np.cos,2],
    ["neumann_nu_o3", np.cos,[5,4]],
    ["neumann_nu_o4", np.cos,4],
    ["free_nu_o2", np.cos,2],
    ["free_nu_o3", np.cos,4],
    ["free_nu_o4", np.cos,4],
    ["free_nu_o2", np.sin,3],
    ["free_nu_o3", np.sin,3],
    ["free_nu_o4", np.sin,5],
]

code=0
locs=["CENTRE", "XLOW", "YLOW", "ZLOW"]
for bdry, func, forder in testdata:
    for loc in locs:
        if isinstance(forder,list):
            order=forder[1 if loc == "YLOW" else 0]
        else:
            order=forder
        code += test(bdry, func, loc)

sys.exit(code)
