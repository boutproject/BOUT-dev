#!/usr/bin/env python3

# Python script to run and analyse MMS test

from __future__ import division
from __future__ import print_function
try:
  from builtins import zip
  from builtins import str
except:
  pass

from boututils.run_wrapper import shell, shell_safe, launch_safe, getmpirun
from boutdata.collect import collect

import pickle

from sys import stdout

from numpy import sqrt, max, abs, mean, array, log, concatenate, pi

MPIRUN = getmpirun()

print("Making MMS wave test")
shell_safe("make > make.log")

# List of NY values to use
nylist = [8, 16, 32, 64, 128, 256]

# Options to test
opts_list = [' mesh:staggergrids=true f:bndry_ydown="dirichlet_smooth(f:solution)" f:bndry_yup="dirichlet_smooth(f:solution)" g:bndry_ydown="dirichlet_smooth(g:solution)" g:bndry_yup="dirichlet_smooth(g:solution)"',
             ' mesh:staggergrids=true f:bndry_ydown="neumann(f:ddy)" f:bndry_yup="neumann(f:ddy)" g:bndry_ydown="neumann(g:ddy)" g:bndry_yup="neumann(g:ddy)"',
             ' mesh:staggergrids=false f:bndry_ydown="dirichlet_smooth(f:solution)" f:bndry_yup="dirichlet_smooth(f:solution)" g:bndry_ydown="dirichlet_smooth(g:solution)" g:bndry_yup="dirichlet_smooth(g:solution)"',
             ' mesh:staggergrids=false f:bndry_ydown="neumann(f:ddy)" f:bndry_yup="neumann(f:ddy)" g:bndry_ydown="neumann(g:ddy)" g:bndry_yup="neumann(g:ddy)"']


nout = 1
timestep = 1

nproc = 1

varlist = ["f", "g"]
markers = ['bo', 'r^']
labels = ["f", "g"]

success = True
for i,opts in enumerate(opts_list):
    error_2 = {}
    error_inf = {}
    for var in varlist:
        error_2[var]   = []  # The L2 error (RMS)
        error_inf[var] = []  # The maximum error

    for ny in nylist:
        dy = 2.*pi / ny
        args = "mesh:ny="+str(ny)+" mesh:dy="+str(dy)+" nout="+str(nout)+" timestep="+str(timestep)+opts
        
        print("Running with " + args)

        # Delete old data
        shell("rm data/BOUT.dmp.*.nc")
        
        # Command to run
        cmd = "./wave "+args
        # Launch using MPI
        s, out = launch_safe(cmd, runcmd=MPIRUN, nproc=nproc, pipe=True)

        # Save output to log file
        with open("run.log."+str(ny), "w") as f:
            f.write(out)

        for var in varlist:
            # Collect data
            E = collect("E_"+var, tind=[nout,nout], info=False, path="data")
            E = E[0,0,:,0]
            
            # Average error over domain

            l2 = sqrt(mean(E**2))
            linf = max(abs(E))
        
            error_2[var].append( l2 )
            error_inf[var].append( linf )

            print("Error norm %s: l-2 %f l-inf %f" % (var, l2, linf))

    ## Save data
    #with open("wave.pkl", "wb") as output:
    #    pickle.dump(nylist, output)
    #    pickle.dump(error_2, output)
    #    pickle.dump(error_inf, output)

    # Calculate grid spacing
    dy = 1. / array(nylist)

    # Calculate convergence order
    for var in varlist:
      order = log(error_2[var][-1] / error_2[var][-2]) / log(dy[-1] / dy[-2])
      stdout.write("%s Convergence order = %f" % (var, order))

      if 1.8 < order < 2.2: # Should be second order accurate
        print("............ PASS with", opts)
      else:
        success = False
        print("............ FAIL with", opts)

    # plot errors
    try:
      import matplotlib.pyplot as plt
      for var,mark,label in zip(varlist, markers, labels):
        plt.plot(dy, error_2[var], '-'+mark, label="%s order=%.2f" % (label, order))
        plt.plot(dy, error_inf[var], '--'+mark)

      plt.legend(loc="upper left")
      plt.grid()

      plt.yscale('log')
      plt.xscale('log')

      plt.xlabel(r'Mesh spacing $\delta y$')
      plt.ylabel("Error norm")

      plt.savefig("norm%i.pdf"%i)

      #plt.show()
      plt.close()
    except:
      # Plotting could fail for any number of reasons, and the actual
      # error raised may depend on, among other things, the current
      # matplotlib backend, so catch everything
      pass

if success:
  print(" => Test passed")
  exit(0)
else:
  print(" => Test failed")
  exit(1)
