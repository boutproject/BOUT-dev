#!/usr/bin/env python3
#
# Python script to run and analyse MMS test
#

# Cores: 2
# requires: zoidberg

import argparse
import json
import pathlib
import sys
from time import time
from typing import Any

import boutconfig as conf
import zoidberg as zb
from boutdata.collect import collect
from boututils.run_wrapper import build_and_log, launch_safe
from numpy import arange, array, linspace, log, polyfit
from scipy.interpolate import RectBivariateSpline as RBS

# Global parameters
DIRECTORY = "data"
NPROC = 2
MTHREAD = 2
OPERATORS = ("grad_par", "grad2_par2", "div_par", "div_par_K_grad_par")
NX = 3
# Resolution in y and z
NLIST = [8, 16, 32, 64, 128]
dx = 1.0 / array(NLIST)


def myRBS(a, b, c):
    """RectBivariateSpline, but automatically tune spline degree for small arrays"""
    mx, _ = c.shape
    kx = max(mx - 1, 1)
    kx = min(kx, 3)
    return RBS(a, b, c, kx=kx)


zb.poloidal_grid.RectBivariateSpline = myRBS


def quiet_collect(name: str) -> float:
    # Index to return a plain (numpy) float rather than `BoutArray`
    return collect(
        name,
        tind=[1, 1],
        info=False,
        path=DIRECTORY,
        xguards=False,
        yguards=False,
    )[()]


def assert_convergence(error, dx, name, order) -> bool:
    fit = polyfit(log(dx), log(error), 1)
    order = fit[0]
    print(f"{name} convergence order = {order:f} (fit)", end="")

    order = log(error[-2] / error[-1]) / log(dx[-2] / dx[-1])
    print(f", {order:f} (small spacing)", end="")

    # Should be close to the expected order
    success = order > order * 0.95
    print(f"\t............ {'PASS' if success else 'FAIL'}")

    return success


def run_fci_operators(
    nslice: int, nz: int, yperiodic: bool, name: str
) -> dict[str, float]:
    # Define the magnetic field using new poloidal gridding method
    # Note that the Bz and Bzprime parameters here must be the same as in mms.py
    field = zb.field.Slab(Bz=0.05, Bzprime=0.1)
    # Create rectangular poloidal grids
    poloidal_grid = zb.poloidal_grid.RectangularPoloidalGrid(NX, nz, 0.1, 1.0, MXG=1)
    # Set the ylength and y locations
    ylength = 10.0

    if yperiodic:
        ycoords = linspace(0.0, ylength, nz, endpoint=False)
    else:
        # Doesn't include the end points
        ycoords = (arange(nz) + 0.5) * ylength / float(nz)

    # Create the grid
    grid = zb.grid.Grid(poloidal_grid, ycoords, ylength, yperiodic=yperiodic)
    maps = zb.make_maps(grid, field, nslice=nslice, quiet=True, MXG=1)
    zb.write_maps(
        grid,
        field,
        maps,
        new_names=False,
        metric2d=conf.isMetric2D(),
        quiet=True,
    )

    # Command to run
    args = f"MZ={nz} MYG={nslice} mesh:paralleltransform:y_periodic={yperiodic} mesh:ddy:first={name}"
    cmd = f"./fci_mms {args}"
    print(f"Running command: {cmd}", end="")

    # Launch using MPI
    start = time()
    status, out = launch_safe(cmd, nproc=NPROC, mthread=MTHREAD, pipe=True)
    print(f" ... done in {time() - start:.3}s")

    # Save output to log file
    pathlib.Path(f"run.log.{nz}").write_text(out)

    if status:
        print(f"Run failed!\nOutput was:\n{out}")
        sys.exit(status)

    return {
        operator: {
            "l_2": quiet_collect(f"{operator}_l_2"),
            "l_inf": quiet_collect(f"{operator}_l_inf"),
        }
        for operator in OPERATORS
    }


def transpose(
    errors: list[dict[str, dict[str, float]]],
) -> dict[str, dict[str, list[float]]]:
    """Turn a list of {operator: error} into a dict of {operator: [errors]}"""

    kinds = ("l_2", "l_inf")
    result = {operator: {kind: [] for kind in kinds} for operator in OPERATORS}
    for error in errors:
        for k, v in error.items():
            for kind in kinds:
                result[k][kind].append(v[kind])
    return result


def check_fci_operators(case: dict) -> bool:
    failures = []

    nslice = case["nslice"]
    yperiodic = case["yperiodic"]
    name = case["name"]
    order = case["order"]

    all_errors = []

    for n in NLIST:
        errors = run_fci_operators(nslice, n, yperiodic, name)
        all_errors.append(errors)

        for operator in OPERATORS:
            l_2 = errors[operator]["l_2"]
            l_inf = errors[operator]["l_inf"]

            print(f"{operator} errors: l-2 {l_2:f} l-inf {l_inf:f}")

    final_errors = transpose(all_errors)
    for operator in OPERATORS:
        test_name = f"{operator} {name}"
        success = assert_convergence(
            final_errors[operator]["l_2"], dx, test_name, order
        )
        if not success:
            failures.append(test_name)

    return final_errors, failures


def make_plots(cases):
    try:
        import matplotlib.pyplot as plt
    except ImportError:
        print("No matplotlib")
        return

    num_operators = len(OPERATORS)
    fig, axes = plt.subplots(1, num_operators, figsize=(num_operators * 4, 4))

    for ax, operator in zip(axes, OPERATORS):
        for name, case in cases.items():
            ax.loglog(dx, case[operator]["l_2"], "-", label=f"{name} $l_2$")
            ax.loglog(dx, case[operator]["l_inf"], "--", label=f"{name} $l_\\inf$")
        ax.legend(loc="upper left")
        ax.grid()
        ax.set_title(f"Error scaling for {operator}")
        ax.set_xlabel(r"Mesh spacing $\delta x$")
        ax.set_ylabel("Error norm")

    fig.tight_layout()
    fig.savefig("fci_mms.pdf")
    print("Plot saved to fci_mms.pdf")

    if args.show_plots:
        plt.show()
    plt.close()


def make_case(nslice: int, yperiodic: bool) -> dict[str, Any]:
    """
    nslice:
        Number of parallel slices (in each direction)
    yperiodic:
        Run with periodic Y
    """
    order = nslice * 2
    return {
        "nslice": nslice,
        # Which central difference scheme to use and its expected order
        "order": order,
        "name": f"C{order}",
        "yperiodic": yperiodic,
    }


if __name__ == "__main__":
    build_and_log("FCI MMS test")

    parser = argparse.ArgumentParser("Error scaling test for FCI operators")
    parser.add_argument(
        "--make-plots", action="store_true", help="Create plots of error scaling"
    )
    parser.add_argument(
        "--show-plots",
        action="store_true",
        help="Stop and show plots, implies --make-plots",
    )
    parser.add_argument(
        "--dump-errors",
        type=str,
        help="Output file to dump errors as JSON",
        default="fci_operator_errors.json",
    )

    args = parser.parse_args()

    success = True
    failures = []
    cases = {
        "nslice=1": make_case(nslice=1, yperiodic=True),
    }

    for case in cases.values():
        error2, failures_ = check_fci_operators(case)
        case.update(error2)
        failures.extend(failures_)
        success &= len(failures) == 0

    if args.dump_errors:
        pathlib.Path(args.dump_errors).write_text(json.dumps(cases))

    if args.make_plots or args.show_plots:
        make_plots(cases)

    if success:
        print("\nAll tests passed")
    else:
        print("\nSome tests failed:")
        for failure in failures:
            print(f"\t{failure}")

    sys.exit(0 if success else 1)
