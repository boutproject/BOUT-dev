#!/usr/bin/env python3
#
# Python script to run and analyse MMS test
#

# Cores: 2
# requires: zoidberg

import pathlib
import pickle
import sys

import boutconfig as conf
import zoidberg as zb
from boutdata.collect import collect
from boututils.run_wrapper import build_and_log, launch_safe
from numpy import arange, array, linspace, log, polyfit
from scipy.interpolate import RectBivariateSpline as RBS


def myRBS(a, b, c):
    mx, _ = c.shape
    kx = max(mx - 1, 1)
    kx = min(kx, 3)
    return RBS(a, b, c, kx=kx)


zb.poloidal_grid.RectBivariateSpline = myRBS

nx = 3  # Not changed for these tests

# Resolution in y and z
nlist = [8, 16, 32, 64, 128]

# Number of parallel slices (in each direction)
nslices = [1]

directory = "data"

nproc = 2
mthread = 2

success = True

error_2 = {}
error_inf = {}
method_orders = {}

# Run with periodic Y?
yperiodic = True

failures = []

build_and_log("FCI MMS test")

for nslice in nslices:
    error_2[nslice] = []
    error_inf[nslice] = []

    # Which central difference scheme to use and its expected order
    order = nslice * 2
    name = f"C{order}"
    method_orders[nslice] = {"name": name, "order": order}

    for n in nlist:
        # Define the magnetic field using new poloidal gridding method
        # Note that the Bz and Bzprime parameters here must be the same as in mms.py
        field = zb.field.Slab(Bz=0.05, Bzprime=0.1)
        # Create rectangular poloidal grids
        poloidal_grid = zb.poloidal_grid.RectangularPoloidalGrid(nx, n, 0.1, 1.0, MXG=1)
        # Set the ylength and y locations
        ylength = 10.0

        if yperiodic:
            ycoords = linspace(0.0, ylength, n, endpoint=False)
        else:
            # Doesn't include the end points
            ycoords = (arange(n) + 0.5) * ylength / float(n)

        # Create the grid
        grid = zb.grid.Grid(poloidal_grid, ycoords, ylength, yperiodic=yperiodic)
        # Make and write maps
        maps = zb.make_maps(grid, field, nslice=nslice, quiet=True, MXG=1)
        zb.write_maps(
            grid, field, maps, new_names=False, metric2d=conf.isMetric2D(), quiet=True
        )

        # Command to run
        args = f" MZ={n} MYG={nslice} mesh:paralleltransform:y_periodic={yperiodic} mesh:ddy:first={name}"
        cmd = f"./fci_mms {args}"

        print(f"Running command: {cmd}")

        # Launch using MPI
        s, out = launch_safe(cmd, nproc=nproc, mthread=mthread, pipe=True)

        # Save output to log file
        pathlib.Path(f"run.log.{n}").write_text(out)

        if s:
            print(f"Run failed!\nOutput was:\n{out}")
            sys.exit(s)

        # Collect data
        l_2 = collect(
            "l_2", tind=[1, 1], info=False, path=directory, xguards=False, yguards=False
        )
        l_inf = collect(
            "l_inf",
            tind=[1, 1],
            info=False,
            path=directory,
            xguards=False,
            yguards=False,
        )

        error_2[nslice].append(l_2)
        error_inf[nslice].append(l_inf)

        print(f"Errors : l-2 {l_2:f} l-inf {l_inf:f}")

    dx = 1.0 / array(nlist)

    # Calculate convergence order
    fit = polyfit(log(dx), log(error_2[nslice]), 1)
    order = fit[0]
    print(f"Convergence order = {order:f} (fit)", end="")

    order = log(error_2[nslice][-2] / error_2[nslice][-1]) / log(dx[-2] / dx[-1])
    print(f", {order:f} (small spacing)")

    # Should be close to the expected order
    if order > order * 0.95:
        print("............ PASS\n")
    else:
        print("............ FAIL\n")
        success = False
        failures.append(name)


with open("fci_mms.pkl", "wb") as output:
    pickle.dump(nlist, output)
    for nslice in nslices:
        pickle.dump(error_2[nslice], output)
        pickle.dump(error_inf[nslice], output)

# Do we want to show the plot as well as save it to file.
show_plot = True

if False:
    try:
        # Plot using matplotlib if available
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots(1, 1)

        for nslice in nslices:
            name = method_orders[nslice]["name"]
            ax.plot(dx, error_2[nslice], "-", label=f"{name} $l_2$")
            ax.plot(dx, error_inf[nslice], "--", label=f"{name} $l_\\inf$")
        ax.legend(loc="upper left")
        ax.grid()
        ax.set_yscale("log")
        ax.set_xscale("log")
        ax.set_title("error scaling")
        ax.set_xlabel(r"Mesh spacing $\delta x$")
        ax.set_ylabel("Error norm")

        plt.savefig("fci_mms.pdf")

        print("Plot saved to fci_mms.pdf")

        if show_plot:
            plt.show()
        plt.close()
    except ImportError:
        print("No matplotlib")

if success:
    print("All tests passed")
    sys.exit(0)
else:
    print("Some tests failed:")
    for failure in failures:
        print(f"\t{failure}")
    sys.exit(1)
