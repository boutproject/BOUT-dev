#!/usr/bin/env python3
#
# Python script to run and analyse MMS test
#

# Cores: 2
# requires: zoidberg

import pathlib
import pickle
import sys
from collections import defaultdict

import boutconfig as conf
import zoidberg as zb
from boutdata.collect import collect
from boututils.run_wrapper import build_and_log, launch_safe
from numpy import arange, array, linspace, log, polyfit
from scipy.interpolate import RectBivariateSpline as RBS


def myRBS(a, b, c):
    """RectBivariateSpline, but automatically tune spline degree for small arrays"""
    mx, _ = c.shape
    kx = max(mx - 1, 1)
    kx = min(kx, 3)
    return RBS(a, b, c, kx=kx)


zb.poloidal_grid.RectBivariateSpline = myRBS


def quiet_collect(name: str):
    return collect(
        name, tind=[1, 1], info=False, path=directory, xguards=False, yguards=False,
    )


nx = 3  # Not changed for these tests

# Resolution in y and z
nlist = [8, 16, 32, 64, 128]

# Number of parallel slices (in each direction)
nslices = [1]

directory = "data"

nproc = 2
mthread = 2

success = True

error_2 = {}
error_inf = {}
method_orders = {}

# Run with periodic Y?
yperiodic = True

failures = []
operators = ("grad_par", "grad2_par2")

build_and_log("FCI MMS test")


def assert_convergence(error, dx, name, order) -> bool:
    fit = polyfit(log(dx), log(error), 1)
    order = fit[0]
    print(f"{name} convergence order = {order:f} (fit)", end="")

    order = log(error[-2] / error[-1]) / log(dx[-2] / dx[-1])
    print(f", {order:f} (small spacing)", end="")

    # Should be close to the expected order
    success = order > order * 0.95
    print(f" ............ {'PASS' if success else 'FAIL'}")

    return success


for nslice in nslices:
    error_2[nslice] = defaultdict(list)
    error_inf[nslice] = defaultdict(list)

    # Which central difference scheme to use and its expected order
    order = nslice * 2
    name = f"C{order}"
    method_orders[nslice] = {"name": name, "order": order}

    for n in nlist:
        # Define the magnetic field using new poloidal gridding method
        # Note that the Bz and Bzprime parameters here must be the same as in mms.py
        field = zb.field.Slab(Bz=0.05, Bzprime=0.1)
        # Create rectangular poloidal grids
        poloidal_grid = zb.poloidal_grid.RectangularPoloidalGrid(nx, n, 0.1, 1.0, MXG=1)
        # Set the ylength and y locations
        ylength = 10.0

        if yperiodic:
            ycoords = linspace(0.0, ylength, n, endpoint=False)
        else:
            # Doesn't include the end points
            ycoords = (arange(n) + 0.5) * ylength / float(n)

        # Create the grid
        grid = zb.grid.Grid(poloidal_grid, ycoords, ylength, yperiodic=yperiodic)
        maps = zb.make_maps(grid, field, nslice=nslice, quiet=True, MXG=1)
        zb.write_maps(
            grid, field, maps, new_names=False, metric2d=conf.isMetric2D(), quiet=True,
        )

        # Command to run
        args = f" MZ={n} MYG={nslice} mesh:paralleltransform:y_periodic={yperiodic} mesh:ddy:first={name}"
        cmd = f"./fci_mms {args}"
        print(f"Running command: {cmd}")

        # Launch using MPI
        status, out = launch_safe(cmd, nproc=nproc, mthread=mthread, pipe=True)

        # Save output to log file
        pathlib.Path(f"run.log.{n}").write_text(out)

        if status:
            print(f"Run failed!\nOutput was:\n{out}")
            sys.exit(status)

        # Collect data
        for operator in operators:
            l_2 = quiet_collect(f"{operator}_l_2")
            l_inf = quiet_collect(f"{operator}_l_inf")

            error_2[nslice][operator].append(l_2)
            error_inf[nslice][operator].append(l_inf)

            print(f"{operator} errors: l-2 {l_2:f} l-inf {l_inf:f}")

    dx = 1.0 / array(nlist)
    for operator in operators:
        test_name = f"{operator} {name}"
        success &= assert_convergence(error_2[nslice][operator], dx, test_name, order)
        if not success:
            failures.append(test_name)


with pathlib.Path("fci_mms.pkl").open("wb") as output:
    pickle.dump(nlist, output)
    pickle.dump(error_2, output)
    pickle.dump(error_inf, output)

# Do we want to show the plot as well as save it to file.
show_plot = True

if False:
    try:
        # Plot using matplotlib if available
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots(1, 1)

        for nslice in nslices:
            name = method_orders[nslice]["name"]
            ax.plot(dx, error_2[nslice], "-", label=f"{name} $l_2$")
            ax.plot(dx, error_inf[nslice], "--", label=f"{name} $l_\\inf$")
        ax.legend(loc="upper left")
        ax.grid()
        ax.set_yscale("log")
        ax.set_xscale("log")
        ax.set_title("error scaling")
        ax.set_xlabel(r"Mesh spacing $\delta x$")
        ax.set_ylabel("Error norm")

        plt.savefig("fci_mms.pdf")

        print("Plot saved to fci_mms.pdf")

        if show_plot:
            plt.show()
        plt.close()
    except ImportError:
        print("No matplotlib")

if success:
    print("\nAll tests passed")
else:
    print("\nSome tests failed:")
    for failure in failures:
        print(f"\t{failure}")

sys.exit(0 if success else 1)
