// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
#include <bout/scorepwrapper.hxx>

// Do the actual multiplication of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_multiplication(BoutReal *__restrict__ result,
                                                    const BoutReal *__restrict__ lhs,
                                                    const BoutReal *__restrict__ rhs,
                                                    int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs[i];
  }
}

// Provide the C++ wrapper for multiplication of Field3D and Field3D
Field3D operator*(const Field3D &lhs, const Field3D &rhs) {
  SCOREP0();
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator*(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx * localmesh->LocalNy *
                                                     localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by multiplication with Field3D
void autogen_Field3D_Field3D_multiplication(BoutReal *__restrict__ lhs,
                                            const BoutReal *__restrict__ rhs, int len) {
  SCOREP0();

#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs[i];
  }
}

// Provide the C++ operator to update Field3D by multiplication with Field3D
Field3D &Field3D::operator*=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator*=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_multiplication(&(*this)[i], &rhs[i],
                                           fieldmesh->LocalNx * fieldmesh->LocalNy *
                                               fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// Do the actual division of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_division(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs[i];
  }
}

// Provide the C++ wrapper for division of Field3D and Field3D
Field3D operator/(const Field3D &lhs, const Field3D &rhs) {
  SCOREP0();
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator/(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy *
                                               localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by division with Field3D
void autogen_Field3D_Field3D_division(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int len) {
  SCOREP0();

#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs[i];
  }
}

// Provide the C++ operator to update Field3D by division with Field3D
Field3D &Field3D::operator/=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator/=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_division(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy *
                                         fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// Do the actual addition of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_addition(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int len) {
  SCOREP0();

#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs[i];
  }
}

// Provide the C++ wrapper for addition of Field3D and Field3D
Field3D operator+(const Field3D &lhs, const Field3D &rhs) {
  SCOREP0();
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator+(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy *
                                               localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by addition with Field3D
void autogen_Field3D_Field3D_addition(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int len) {
  SCOREP0();

#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs[i];
  }
}

// Provide the C++ operator to update Field3D by addition with Field3D
Field3D &Field3D::operator+=(const Field3D &rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator+=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_addition(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy *
                                         fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// Do the actual subtraction of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_subtraction(BoutReal *__restrict__ result,
                                                 const BoutReal *__restrict__ lhs,
                                                 const BoutReal *__restrict__ rhs,
                                                 int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs[i];
  }
}

// Provide the C++ wrapper for subtraction of Field3D and Field3D
Field3D operator-(const Field3D &lhs, const Field3D &rhs) {
  SCOREP0();
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator-(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx * localmesh->LocalNy *
                                                  localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by subtraction with Field3D
void autogen_Field3D_Field3D_subtraction(BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs[i];
  }
}

// Provide the C++ operator to update Field3D by subtraction with Field3D
Field3D &Field3D::operator-=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator-=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_subtraction(&(*this)[i], &rhs[i],
                                        fieldmesh->LocalNx * fieldmesh->LocalNy *
                                            fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// Do the actual multiplication of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_multiplication(BoutReal *__restrict__ result,
                                                    const BoutReal *__restrict__ lhs,
                                                    const BoutReal *__restrict__ rhs,
                                                    int nx, int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] * rhs[y + x * ny];
      }
}

// Provide the C++ wrapper for multiplication of Field3D and Field2D
Field3D operator*(const Field3D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx, localmesh->LocalNy,
                                                 localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by multiplication with Field2D
void autogen_Field3D_Field2D_multiplication(BoutReal *__restrict__ lhs,
                                            const BoutReal *__restrict__ rhs, int nx,
                                            int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] *= rhs[y + x * ny];
      }
}

// Provide the C++ operator to update Field3D by multiplication with Field2D
Field3D &Field3D::operator*=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_multiplication(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                           fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// Do the actual division of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_division(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int nx,
                                              int ny, int nz) {
  SCOREP0();

#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] / rhs[y + x * ny];
      }
}

// Provide the C++ wrapper for division of Field3D and Field2D
Field3D operator/(const Field3D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by division with Field2D
void autogen_Field3D_Field2D_division(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int nx, int ny,
                                      int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] /= rhs[y + x * ny];
      }
}

// Provide the C++ operator to update Field3D by division with Field2D
Field3D &Field3D::operator/=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_division(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                     fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// Do the actual addition of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_addition(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int nx,
                                              int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] + rhs[y + x * ny];
      }
}

// Provide the C++ wrapper for addition of Field3D and Field2D
Field3D operator+(const Field3D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by addition with Field2D
void autogen_Field3D_Field2D_addition(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int nx, int ny,
                                      int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] += rhs[y + x * ny];
      }
}

// Provide the C++ operator to update Field3D by addition with Field2D
Field3D &Field3D::operator+=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_addition(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                     fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// Do the actual subtraction of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_subtraction(BoutReal *__restrict__ result,
                                                 const BoutReal *__restrict__ lhs,
                                                 const BoutReal *__restrict__ rhs, int nx,
                                                 int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] - rhs[y + x * ny];
      }
}

// Provide the C++ wrapper for subtraction of Field3D and Field2D
Field3D operator-(const Field3D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx, localmesh->LocalNy,
                                              localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by subtraction with Field2D
void autogen_Field3D_Field2D_subtraction(BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int nx, int ny,
                                         int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] -= rhs[y + x * ny];
      }
}

// Provide the C++ operator to update Field3D by subtraction with Field2D
Field3D &Field3D::operator-=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_subtraction(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                        fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// Do the actual multiplication of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_multiplication(BoutReal *__restrict__ result,
                                                     const BoutReal *__restrict__ lhs,
                                                     const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs;
  }
}

// Provide the C++ wrapper for multiplication of Field3D and BoutReal
Field3D operator*(const Field3D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_multiplication(
      &result[i], &lhs[i], rhs,
      localmesh->LocalNx * localmesh->LocalNy * localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by multiplication with BoutReal
void autogen_Field3D_BoutReal_multiplication(BoutReal *__restrict__ lhs,
                                             const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs;
  }
}

// Provide the C++ operator to update Field3D by multiplication with BoutReal
Field3D &Field3D::operator*=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_multiplication(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// Do the actual division of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_division(BoutReal *__restrict__ result,
                                               const BoutReal *__restrict__ lhs,
                                               const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs;
  }
}

// Provide the C++ wrapper for division of Field3D and BoutReal
Field3D operator/(const Field3D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_division(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by division with BoutReal
void autogen_Field3D_BoutReal_division(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                       int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs;
  }
}

// Provide the C++ operator to update Field3D by division with BoutReal
Field3D &Field3D::operator/=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  SCOREP0();
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_division(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// Do the actual addition of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_addition(BoutReal *__restrict__ result,
                                               const BoutReal *__restrict__ lhs,
                                               const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs;
  }
}

// Provide the C++ wrapper for addition of Field3D and BoutReal
Field3D operator+(const Field3D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_addition(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by addition with BoutReal
void autogen_Field3D_BoutReal_addition(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                       int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs;
  }
}

// Provide the C++ operator to update Field3D by addition with BoutReal
Field3D &Field3D::operator+=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_addition(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// Do the actual subtraction of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_subtraction(BoutReal *__restrict__ result,
                                                  const BoutReal *__restrict__ lhs,
                                                  const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs;
  }
}

// Provide the C++ wrapper for subtraction of Field3D and BoutReal
Field3D operator-(const Field3D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_subtraction(&result[i], &lhs[i], rhs,
                                               localmesh->LocalNx * localmesh->LocalNy *
                                                   localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

// Provide the C function to update Field3D by subtraction with BoutReal
void autogen_Field3D_BoutReal_subtraction(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                          int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs;
  }
}

// Provide the C++ operator to update Field3D by subtraction with BoutReal
Field3D &Field3D::operator-=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_subtraction(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// Do the actual multiplication of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_multiplication(BoutReal *__restrict__ result,
                                                    const BoutReal *__restrict__ lhs,
                                                    const BoutReal *__restrict__ rhs,
                                                    int nx, int ny, int nz) {
  SCOREP0();

#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] * rhs[z + nz * (y + ny * x)];
      }
}

// Provide the C++ wrapper for multiplication of Field2D and Field3D
Field3D operator*(const Field2D &lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx, localmesh->LocalNy,
                                                 localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual division of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_division(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int nx,
                                              int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] / rhs[z + nz * (y + ny * x)];
      }
}

// Provide the C++ wrapper for division of Field2D and Field3D
Field3D operator/(const Field2D &lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual addition of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_addition(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int nx,
                                              int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] + rhs[z + nz * (y + ny * x)];
      }
}

// Provide the C++ wrapper for addition of Field2D and Field3D
Field3D operator+(const Field2D &lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual subtraction of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_subtraction(BoutReal *__restrict__ result,
                                                 const BoutReal *__restrict__ lhs,
                                                 const BoutReal *__restrict__ rhs, int nx,
                                                 int ny, int nz) {

  SCOREP0();
#pragma omp parallel for collapse(3)
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] - rhs[z + nz * (y + ny * x)];
      }
}

// Provide the C++ wrapper for subtraction of Field2D and Field3D
Field3D operator-(const Field2D &lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx, localmesh->LocalNy,
                                              localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual multiplication of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_multiplication(BoutReal *__restrict__ result,
                                                    const BoutReal *__restrict__ lhs,
                                                    const BoutReal *__restrict__ rhs,
                                                    int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs[i];
  }
}

// Provide the C++ wrapper for multiplication of Field2D and Field2D
Field2D operator*(const Field2D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by multiplication with Field2D
void autogen_Field2D_Field2D_multiplication(BoutReal *__restrict__ lhs,
                                            const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs[i];
  }
}

// Provide the C++ operator to update Field2D by multiplication with Field2D
Field2D &Field2D::operator*=(const Field2D &rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_multiplication(&(*this)[i], &rhs[i],
                                           fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// Do the actual division of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_division(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs[i];
  }
}

// Provide the C++ wrapper for division of Field2D and Field2D
Field2D operator/(const Field2D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by division with Field2D
void autogen_Field2D_Field2D_division(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs[i];
  }
}

// Provide the C++ operator to update Field2D by division with Field2D
Field2D &Field2D::operator/=(const Field2D &rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_division(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// Do the actual addition of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_addition(BoutReal *__restrict__ result,
                                              const BoutReal *__restrict__ lhs,
                                              const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs[i];
  }
}

// Provide the C++ wrapper for addition of Field2D and Field2D
Field2D operator+(const Field2D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by addition with Field2D
void autogen_Field2D_Field2D_addition(BoutReal *__restrict__ lhs,
                                      const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs[i];
  }
}

// Provide the C++ operator to update Field2D by addition with Field2D
Field2D &Field2D::operator+=(const Field2D &rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_addition(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// Do the actual subtraction of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_subtraction(BoutReal *__restrict__ result,
                                                 const BoutReal *__restrict__ lhs,
                                                 const BoutReal *__restrict__ rhs,
                                                 int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs[i];
  }
}

// Provide the C++ wrapper for subtraction of Field2D and Field2D
Field2D operator-(const Field2D &lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by subtraction with Field2D
void autogen_Field2D_Field2D_subtraction(BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs[i];
  }
}

// Provide the C++ operator to update Field2D by subtraction with Field2D
Field2D &Field2D::operator-=(const Field2D &rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_subtraction(&(*this)[i], &rhs[i],
                                        fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// Do the actual multiplication of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_multiplication(BoutReal *__restrict__ result,
                                                     const BoutReal *__restrict__ lhs,
                                                     const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs;
  }
}

// Provide the C++ wrapper for multiplication of Field2D and BoutReal
Field2D operator*(const Field2D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_multiplication(
      &result[i], &lhs[i], rhs, localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by multiplication with BoutReal
void autogen_Field2D_BoutReal_multiplication(BoutReal *__restrict__ lhs,
                                             const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs;
  }
}

// Provide the C++ operator to update Field2D by multiplication with BoutReal
Field2D &Field2D::operator*=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_multiplication(&(*this)[i], rhs,
                                            fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// Do the actual division of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_division(BoutReal *__restrict__ result,
                                               const BoutReal *__restrict__ lhs,
                                               const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs;
  }
}

// Provide the C++ wrapper for division of Field2D and BoutReal
Field2D operator/(const Field2D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_division(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by division with BoutReal
void autogen_Field2D_BoutReal_division(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                       int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs;
  }
}

// Provide the C++ operator to update Field2D by division with BoutReal
Field2D &Field2D::operator/=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_division(&(*this)[i], rhs,
                                      fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// Do the actual addition of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_addition(BoutReal *__restrict__ result,
                                               const BoutReal *__restrict__ lhs,
                                               const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs;
  }
}

// Provide the C++ wrapper for addition of Field2D and BoutReal
Field2D operator+(const Field2D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_addition(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by addition with BoutReal
void autogen_Field2D_BoutReal_addition(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                       int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs;
  }
}

// Provide the C++ operator to update Field2D by addition with BoutReal
Field2D &Field2D::operator+=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_addition(&(*this)[i], rhs,
                                      fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// Do the actual subtraction of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_subtraction(BoutReal *__restrict__ result,
                                                  const BoutReal *__restrict__ lhs,
                                                  const BoutReal rhs, int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs;
  }
}

// Provide the C++ wrapper for subtraction of Field2D and BoutReal
Field2D operator-(const Field2D &lhs, const BoutReal rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_subtraction(&result[i], &lhs[i], rhs,
                                               localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Provide the C function to update Field2D by subtraction with BoutReal
void autogen_Field2D_BoutReal_subtraction(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                          int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs;
  }
}

// Provide the C++ operator to update Field2D by subtraction with BoutReal
Field2D &Field2D::operator-=(const BoutReal rhs) {
  SCOREP0();
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_subtraction(&(*this)[i], rhs,
                                         fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// Do the actual multiplication of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_multiplication(BoutReal *__restrict__ result,
                                                     const BoutReal lhs,
                                                     const BoutReal *__restrict__ rhs,
                                                     int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs * rhs[i];
  }
}

// Provide the C++ wrapper for multiplication of BoutReal and Field3D
Field3D operator*(const BoutReal lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_multiplication(
      &result[i], lhs, &rhs[i],
      localmesh->LocalNx * localmesh->LocalNy * localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual division of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_division(BoutReal *__restrict__ result,
                                               const BoutReal lhs,
                                               const BoutReal *__restrict__ rhs,
                                               int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs / rhs[i];
  }
}

// Provide the C++ wrapper for division of BoutReal and Field3D
Field3D operator/(const BoutReal lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_division(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual addition of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_addition(BoutReal *__restrict__ result,
                                               const BoutReal lhs,
                                               const BoutReal *__restrict__ rhs,
                                               int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs + rhs[i];
  }
}

// Provide the C++ wrapper for addition of BoutReal and Field3D
Field3D operator+(const BoutReal lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_addition(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual subtraction of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_subtraction(BoutReal *__restrict__ result,
                                                  const BoutReal lhs,
                                                  const BoutReal *__restrict__ rhs,
                                                  int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs - rhs[i];
  }
}

// Provide the C++ wrapper for subtraction of BoutReal and Field3D
Field3D operator-(const BoutReal lhs, const Field3D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_subtraction(&result[i], lhs, &rhs[i],
                                               localmesh->LocalNx * localmesh->LocalNy *
                                                   localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

// Do the actual multiplication of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_multiplication(BoutReal *__restrict__ result,
                                                     const BoutReal lhs,
                                                     const BoutReal *__restrict__ rhs,
                                                     int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs * rhs[i];
  }
}

// Provide the C++ wrapper for multiplication of BoutReal and Field2D
Field2D operator*(const BoutReal lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_multiplication(
      &result[i], lhs, &rhs[i], localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Do the actual division of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_division(BoutReal *__restrict__ result,
                                               const BoutReal lhs,
                                               const BoutReal *__restrict__ rhs,
                                               int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs / rhs[i];
  }
}

// Provide the C++ wrapper for division of BoutReal and Field2D
Field2D operator/(const BoutReal lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_division(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Do the actual addition of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_addition(BoutReal *__restrict__ result,
                                               const BoutReal lhs,
                                               const BoutReal *__restrict__ rhs,
                                               int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs + rhs[i];
  }
}

// Provide the C++ wrapper for addition of BoutReal and Field2D
Field2D operator+(const BoutReal lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_addition(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

// Do the actual subtraction of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_subtraction(BoutReal *__restrict__ result,
                                                  const BoutReal lhs,
                                                  const BoutReal *__restrict__ rhs,
                                                  int len) {

  SCOREP0();
#pragma omp parallel for
  for (int i = 0; i < len; ++i) {
    result[i] = lhs - rhs[i];
  }
}

// Provide the C++ wrapper for subtraction of BoutReal and Field2D
Field2D operator-(const BoutReal lhs, const Field2D &rhs) {

  SCOREP0();
  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_subtraction(&result[i], lhs, &rhs[i],
                                               localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}
