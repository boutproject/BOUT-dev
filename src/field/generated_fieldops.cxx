// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_mul(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field3D and Field3D
Field3D operator*(const Field3D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] * rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field3D_mul(&result[i], &lhs[i], &rhs[i],
                                      msh->LocalNx * msh->LocalNy * msh->LocalNz);
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException(
        "Trying to mul fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_div(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field3D and Field3D
Field3D operator/(const Field3D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] / rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field3D_div(&result[i], &lhs[i], &rhs[i],
                                      msh->LocalNx * msh->LocalNy * msh->LocalNz);
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException(
        "Trying to div fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_plus(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field3D and Field3D
Field3D operator+(const Field3D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] + rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field3D_plus(&result[i], &lhs[i], &rhs[i],
                                       msh->LocalNx * msh->LocalNy * msh->LocalNz);
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException(
        "Trying to plus fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field3D and Field3D
void autogen_Field3D_Field3D_Field3D_minus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field3D and Field3D
Field3D operator-(const Field3D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] - rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field3D_minus(&result[i], &lhs[i], &rhs[i],
                                        msh->LocalNx * msh->LocalNy * msh->LocalNz);
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException(
        "Trying to minus fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_mul(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int nx, int ny,
                                         int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] * rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field3D and Field2D
Field3D operator*(const Field3D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] * rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field2D_mul(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                      msh->LocalNy, msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_div(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int nx, int ny,
                                         int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] / rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field3D and Field2D
Field3D operator/(const Field3D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] / rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field2D_div(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                      msh->LocalNy, msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_plus(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal *__restrict__ rhs, int nx,
                                          int ny, int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] + rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field3D and Field2D
Field3D operator+(const Field3D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] + rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field2D_plus(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                       msh->LocalNy, msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field3D and Field2D
void autogen_Field3D_Field3D_Field2D_minus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal *__restrict__ rhs, int nx,
                                           int ny, int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[z + nz * (y + ny * x)] - rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field3D and Field2D
Field3D operator-(const Field3D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] - rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_Field2D_minus(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                        msh->LocalNy, msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_mul(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field3D and BoutReal
Field3D operator*(const Field3D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_BoutReal_mul(&result[i], &lhs[i], rhs,
                                       msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_div(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field3D and BoutReal
Field3D operator/(const Field3D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_BoutReal_div(&result[i], &lhs[i], rhs,
                                       msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_plus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field3D and BoutReal
Field3D operator+(const Field3D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_BoutReal_plus(&result[i], &lhs[i], rhs,
                                        msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field3D and BoutReal
void autogen_Field3D_Field3D_BoutReal_minus(BoutReal *__restrict__ result,
                                            const BoutReal *__restrict__ lhs,
                                            const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field3D and BoutReal
Field3D operator-(const Field3D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field3D_BoutReal_minus(&result[i], &lhs[i], rhs,
                                         msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(lhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_mul(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int nx, int ny,
                                         int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] * rhs[z + nz * (y + ny * x)];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field2D and Field3D
Field3D operator*(const Field2D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] * rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field2D_Field3D_mul(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                      msh->LocalNy, msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_div(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int nx, int ny,
                                         int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] / rhs[z + nz * (y + ny * x)];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field2D and Field3D
Field3D operator/(const Field2D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] / rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field2D_Field3D_div(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                      msh->LocalNy, msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_plus(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal *__restrict__ rhs, int nx,
                                          int ny, int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] + rhs[z + nz * (y + ny * x)];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field2D and Field3D
Field3D operator+(const Field2D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] + rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field2D_Field3D_plus(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                       msh->LocalNy, msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field2D and Field3D
void autogen_Field3D_Field2D_Field3D_minus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal *__restrict__ rhs, int nx,
                                           int ny, int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        result[z + nz * (y + ny * x)] = lhs[y + x * ny] - rhs[z + nz * (y + ny * x)];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field2D and Field3D
Field3D operator-(const Field2D &lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field3D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] - rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_Field2D_Field3D_minus(&result[i], &lhs[i], &rhs[i], msh->LocalNx,
                                        msh->LocalNy, msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_mul(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field2D and Field2D
Field2D operator*(const Field2D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] * rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_Field2D_mul(&result[i], &lhs[i], &rhs[i],
                                      msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_div(BoutReal *__restrict__ result,
                                         const BoutReal *__restrict__ lhs,
                                         const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field2D and Field2D
Field2D operator/(const Field2D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] / rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_Field2D_div(&result[i], &lhs[i], &rhs[i],
                                      msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_plus(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field2D and Field2D
Field2D operator+(const Field2D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] + rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_Field2D_plus(&result[i], &lhs[i], &rhs[i],
                                       msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field2D and Field2D
void autogen_Field2D_Field2D_Field2D_minus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field2D and Field2D
Field2D operator-(const Field2D &lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  ASSERT1(msh == rhs.getMesh());
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant() && rhs.isConstant()) {
    result = lhs[i] - rhs[i];
    result.makeConstant();
    checkData(result);
    return result;
  }
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_Field2D_minus(&result[i], &lhs[i], &rhs[i],
                                        msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_mul(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] * rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of Field2D and BoutReal
Field2D operator*(const Field2D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    if (lhs[i] == 1) {
      return rhs;
    }
    return lhs[i] * rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_BoutReal_mul(&result[i], &lhs[i], rhs,
                                       msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_div(BoutReal *__restrict__ result,
                                          const BoutReal *__restrict__ lhs,
                                          const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] / rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of Field2D and BoutReal
Field2D operator/(const Field2D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    return lhs[i] / rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_BoutReal_div(&result[i], &lhs[i], rhs,
                                       msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_plus(BoutReal *__restrict__ result,
                                           const BoutReal *__restrict__ lhs,
                                           const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] + rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of Field2D and BoutReal
Field2D operator+(const Field2D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    if (lhs[i] == 0) {
      return rhs;
    }
    return lhs[i] + rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_BoutReal_plus(&result[i], &lhs[i], rhs,
                                        msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of Field2D and BoutReal
void autogen_Field2D_Field2D_BoutReal_minus(BoutReal *__restrict__ result,
                                            const BoutReal *__restrict__ lhs,
                                            const BoutReal rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs[i] - rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of Field2D and BoutReal
Field2D operator-(const Field2D &lhs, const BoutReal rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = lhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (lhs.isConstant()) {
    return lhs[i] - rhs;
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_Field2D_BoutReal_minus(&result[i], &lhs[i], rhs,
                                         msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_mul(BoutReal *__restrict__ result,
                                          const BoutReal lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs * rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of BoutReal and Field3D
Field3D operator*(const BoutReal lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_BoutReal_Field3D_mul(&result[i], lhs, &rhs[i],
                                       msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_div(BoutReal *__restrict__ result,
                                          const BoutReal lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs / rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of BoutReal and Field3D
Field3D operator/(const BoutReal lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_BoutReal_Field3D_div(&result[i], lhs, &rhs[i],
                                       msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_plus(BoutReal *__restrict__ result,
                                           const BoutReal lhs,
                                           const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs + rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of BoutReal and Field3D
Field3D operator+(const BoutReal lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_BoutReal_Field3D_plus(&result[i], lhs, &rhs[i],
                                        msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of BoutReal and Field3D
void autogen_Field3D_BoutReal_Field3D_minus(BoutReal *__restrict__ result,
                                            const BoutReal lhs,
                                            const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs - rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of BoutReal and Field3D
Field3D operator-(const BoutReal lhs, const Field3D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field3D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field3D_BoutReal_Field3D_minus(&result[i], lhs, &rhs[i],
                                         msh->LocalNx * msh->LocalNy * msh->LocalNz);
  result.setLocation(rhs.getLocation());
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual mul of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_mul(BoutReal *__restrict__ result,
                                          const BoutReal lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs * rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for mul of BoutReal and Field2D
Field2D operator*(const BoutReal lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs * rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_BoutReal_Field2D_mul(&result[i], lhs, &rhs[i],
                                       msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual div of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_div(BoutReal *__restrict__ result,
                                          const BoutReal lhs,
                                          const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs / rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for div of BoutReal and Field2D
Field2D operator/(const BoutReal lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 1) {
      return lhs;
    }
    return lhs / rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_BoutReal_Field2D_div(&result[i], lhs, &rhs[i],
                                       msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual plus of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_plus(BoutReal *__restrict__ result,
                                           const BoutReal lhs,
                                           const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs + rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for plus of BoutReal and Field2D
Field2D operator+(const BoutReal lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs + rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_BoutReal_Field2D_plus(&result[i], lhs, &rhs[i],
                                        msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Do the actual minus of BoutReal and Field2D
void autogen_Field2D_BoutReal_Field2D_minus(BoutReal *__restrict__ result,
                                            const BoutReal lhs,
                                            const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    result[i] = lhs - rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ wrapper for minus of BoutReal and Field2D
Field2D operator-(const BoutReal lhs, const Field2D &rhs) {
  Indices i{0, 0, 0};
  Mesh *msh = rhs.getMesh();
  Field2D result(msh);
  result.allocate();
  if (rhs.isConstant()) {
    if (rhs[i] == 0) {
      return lhs;
    }
    return lhs - rhs[i];
  }
  checkData(lhs);
  checkData(rhs);
  autogen_Field2D_BoutReal_Field2D_minus(&result[i], lhs, &rhs[i],
                                         msh->LocalNx * msh->LocalNy);
  checkData(result);
  return result;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by mul with Field3D
void autogen_Field3D_Field3D_mul(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by mul with Field3D
Field3D &Field3D::operator*=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] * rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (*=) non-constant Field3D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) *= rhs[i];
    }
    autogen_Field3D_Field3D_mul(&(*this)[i], &rhs[i],
                                fieldmesh->LocalNx * fieldmesh->LocalNy *
                                    fieldmesh->LocalNz);
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Trying to mul fields of different locations!");
    }
#endif
    checkData(*this);
  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by div with Field3D
void autogen_Field3D_Field3D_div(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by div with Field3D
Field3D &Field3D::operator/=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] / rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (/=) non-constant Field3D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) /= rhs[i];
    }
    autogen_Field3D_Field3D_div(&(*this)[i], &rhs[i],
                                fieldmesh->LocalNx * fieldmesh->LocalNy *
                                    fieldmesh->LocalNz);
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Trying to div fields of different locations!");
    }
#endif
    checkData(*this);
  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by plus with Field3D
void autogen_Field3D_Field3D_plus(BoutReal *__restrict__ lhs,
                                  const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by plus with Field3D
Field3D &Field3D::operator+=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] + rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (+=) non-constant Field3D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) += rhs[i];
    }
    autogen_Field3D_Field3D_plus(&(*this)[i], &rhs[i],
                                 fieldmesh->LocalNx * fieldmesh->LocalNy *
                                     fieldmesh->LocalNz);
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Trying to plus fields of different locations!");
    }
#endif
    checkData(*this);
  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by minus with Field3D
void autogen_Field3D_Field3D_minus(BoutReal *__restrict__ lhs,
                                   const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by minus with Field3D
Field3D &Field3D::operator-=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] - rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (-=) non-constant Field3D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) -= rhs[i];
    }
    autogen_Field3D_Field3D_minus(&(*this)[i], &rhs[i],
                                  fieldmesh->LocalNx * fieldmesh->LocalNy *
                                      fieldmesh->LocalNz);
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Trying to minus fields of different locations!");
    }
#endif
    checkData(*this);
  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by mul with Field2D
void autogen_Field3D_Field2D_mul(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int nx, int ny,
                                 int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] *= rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by mul with Field2D
Field3D &Field3D::operator*=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] * rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (*=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) *= rhs[i];
    }
    autogen_Field3D_Field2D_mul(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                fieldmesh->LocalNy, fieldmesh->LocalNz);
  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by div with Field2D
void autogen_Field3D_Field2D_div(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int nx, int ny,
                                 int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] /= rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by div with Field2D
Field3D &Field3D::operator/=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] / rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (/=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) /= rhs[i];
    }
    autogen_Field3D_Field2D_div(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                fieldmesh->LocalNy, fieldmesh->LocalNz);
  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by plus with Field2D
void autogen_Field3D_Field2D_plus(BoutReal *__restrict__ lhs,
                                  const BoutReal *__restrict__ rhs, int nx, int ny,
                                  int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] += rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by plus with Field2D
Field3D &Field3D::operator+=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] + rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (+=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) += rhs[i];
    }
    autogen_Field3D_Field2D_plus(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                 fieldmesh->LocalNy, fieldmesh->LocalNz);
  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by minus with Field2D
void autogen_Field3D_Field2D_minus(BoutReal *__restrict__ lhs,
                                   const BoutReal *__restrict__ rhs, int nx, int ny,
                                   int nz) {
  for (int x = 0; x < nx; ++x)
    for (int y = 0; y < ny; ++y)
      for (int z = 0; z < nz; ++z) {
        lhs[z + nz * (y + ny * x)] -= rhs[y + x * ny];
      }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by minus with Field2D
Field3D &Field3D::operator-=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] - rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field3D (-=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) -= rhs[i];
    }
    autogen_Field3D_Field2D_minus(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                  fieldmesh->LocalNy, fieldmesh->LocalNz);
  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by mul with BoutReal
void autogen_Field3D_BoutReal_mul(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                  int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by mul with BoutReal
Field3D &Field3D::operator*=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field3D_BoutReal_mul(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);
  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by div with BoutReal
void autogen_Field3D_BoutReal_div(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                  int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by div with BoutReal
Field3D &Field3D::operator/=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field3D_BoutReal_div(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);
  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by plus with BoutReal
void autogen_Field3D_BoutReal_plus(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                   int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by plus with BoutReal
Field3D &Field3D::operator+=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field3D_BoutReal_plus(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);
  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field3D by minus with BoutReal
void autogen_Field3D_BoutReal_minus(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                    int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field3D by minus with BoutReal
Field3D &Field3D::operator-=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field3D_BoutReal_minus(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);
  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by mul with Field2D
void autogen_Field2D_Field2D_mul(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by mul with Field2D
Field2D &Field2D::operator*=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] * rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field2D (*=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) *= rhs[i];
    }
    autogen_Field2D_Field2D_mul(&(*this)[i], &rhs[i],
                                fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by div with Field2D
void autogen_Field2D_Field2D_div(BoutReal *__restrict__ lhs,
                                 const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by div with Field2D
Field2D &Field2D::operator/=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] / rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field2D (/=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 1) {
        return *this;
      }
      return (*this) /= rhs[i];
    }
    autogen_Field2D_Field2D_div(&(*this)[i], &rhs[i],
                                fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by plus with Field2D
void autogen_Field2D_Field2D_plus(BoutReal *__restrict__ lhs,
                                  const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by plus with Field2D
Field2D &Field2D::operator+=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] + rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field2D (+=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) += rhs[i];
    }
    autogen_Field2D_Field2D_plus(&(*this)[i], &rhs[i],
                                 fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by minus with Field2D
void autogen_Field2D_Field2D_minus(BoutReal *__restrict__ lhs,
                                   const BoutReal *__restrict__ rhs, int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs[i];
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by minus with Field2D
Field2D &Field2D::operator-=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    ASSERT1(fieldmesh == rhs.getMesh());
    checkData(*this);
    checkData(rhs);
    if (this->isConstant() && rhs.isConstant()) {
      (*this) = (*this)[i] - rhs[i];
      checkData(*this);
      return *this;
    } else if (this->isConstant()) {
      throw BoutException("Updating constant Field2D (-=) non-constant Field2D: does not "
                          "preserve constness");
    } else if (rhs.isConstant()) {
      if (rhs[i] == 0) {
        return *this;
      }
      return (*this) -= rhs[i];
    }
    autogen_Field2D_Field2D_minus(&(*this)[i], &rhs[i],
                                  fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by mul with BoutReal
void autogen_Field2D_BoutReal_mul(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                  int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] *= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by mul with BoutReal
Field2D &Field2D::operator*=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field2D_BoutReal_mul(&(*this)[i], rhs,
                                 fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by div with BoutReal
void autogen_Field2D_BoutReal_div(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                  int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] /= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by div with BoutReal
Field2D &Field2D::operator/=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field2D_BoutReal_div(&(*this)[i], rhs,
                                 fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by plus with BoutReal
void autogen_Field2D_BoutReal_plus(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                   int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] += rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by plus with BoutReal
Field2D &Field2D::operator+=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field2D_BoutReal_plus(&(*this)[i], rhs,
                                  fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}

// This file is autogenerated - see gen_fieldops.py
// Provide the C function to update Field2D by minus with BoutReal
void autogen_Field2D_BoutReal_minus(BoutReal *__restrict__ lhs, const BoutReal rhs,
                                    int len) {
  for (int i = 0; i < len; ++i) {
    lhs[i] -= rhs;
  }
}
// This file is autogenerated - see gen_fieldops.py
// Provide the C++ operator to update Field2D by minus with BoutReal
Field2D &Field2D::operator-=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    Indices i{0, 0, 0};
    checkData(*this);
    checkData(rhs);
    autogen_Field2D_BoutReal_minus(&(*this)[i], rhs,
                                   fieldmesh->LocalNx * fieldmesh->LocalNy);
  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
