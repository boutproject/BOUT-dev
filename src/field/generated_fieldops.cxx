// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
extern "C" {
void autogen_Field3D_Field3D_Field3D_multiplication(BoutReal *result, const BoutReal *lhs,
                                                    const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for multiplication of Field3D and Field3D
Field3D operator*(const Field3D &lhs, const Field3D &rhs) {
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator*(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx * localmesh->LocalNy *
                                                     localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by multiplication with Field3D
void autogen_Field3D_Field3D_multiplication(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field3D by multiplication with Field3D
Field3D &Field3D::operator*=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator*=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_multiplication(&(*this)[i], &rhs[i],
                                           fieldmesh->LocalNx * fieldmesh->LocalNy *
                                               fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field3D_division(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for division of Field3D and Field3D
Field3D operator/(const Field3D &lhs, const Field3D &rhs) {
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator/(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy *
                                               localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by division with Field3D
void autogen_Field3D_Field3D_division(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field3D by division with Field3D
Field3D &Field3D::operator/=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator/=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_division(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy *
                                         fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field3D_addition(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for addition of Field3D and Field3D
Field3D operator+(const Field3D &lhs, const Field3D &rhs) {
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator+(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy *
                                               localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by addition with Field3D
void autogen_Field3D_Field3D_addition(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field3D by addition with Field3D
Field3D &Field3D::operator+=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator+=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_addition(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy *
                                         fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field3D_subtraction(BoutReal *result, const BoutReal *lhs,
                                                 const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for subtraction of Field3D and Field3D
Field3D operator-(const Field3D &lhs, const Field3D &rhs) {
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException("Error in operator-(Field3D, Field3D): fields at different "
                        "locations. lhs is at %s, rhs is at %s!",
                        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field3D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx * localmesh->LocalNy *
                                                  localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by subtraction with Field3D
void autogen_Field3D_Field3D_subtraction(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field3D by subtraction with Field3D
Field3D &Field3D::operator-=(const Field3D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException("Error in Field3D::operator-=(Field3D): fields at different "
                          "locations. lhs is at %s, rhs is at %s!",
                          strLocation(this->getLocation()),
                          strLocation(rhs.getLocation()));
    }
#endif

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field3D_subtraction(&(*this)[i], &rhs[i],
                                        fieldmesh->LocalNx * fieldmesh->LocalNy *
                                            fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field2D_multiplication(BoutReal *result, const BoutReal *lhs,
                                                    const BoutReal *rhs, int nx, int ny,
                                                    int nz);
}

// Provide the C++ wrapper for multiplication of Field3D and Field2D
Field3D operator*(const Field3D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx, localmesh->LocalNy,
                                                 localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by multiplication with Field2D
void autogen_Field3D_Field2D_multiplication(BoutReal *lhs, const BoutReal *rhs, int nx,
                                            int ny, int nz);
}

// Provide the C++ operator to update Field3D by multiplication with Field2D
Field3D &Field3D::operator*=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_multiplication(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                           fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field2D_division(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int nx, int ny,
                                              int nz);
}

// Provide the C++ wrapper for division of Field3D and Field2D
Field3D operator/(const Field3D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by division with Field2D
void autogen_Field3D_Field2D_division(BoutReal *lhs, const BoutReal *rhs, int nx, int ny,
                                      int nz);
}

// Provide the C++ operator to update Field3D by division with Field2D
Field3D &Field3D::operator/=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_division(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                     fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field2D_addition(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int nx, int ny,
                                              int nz);
}

// Provide the C++ wrapper for addition of Field3D and Field2D
Field3D operator+(const Field3D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by addition with Field2D
void autogen_Field3D_Field2D_addition(BoutReal *lhs, const BoutReal *rhs, int nx, int ny,
                                      int nz);
}

// Provide the C++ operator to update Field3D by addition with Field2D
Field3D &Field3D::operator+=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_addition(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                     fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_Field2D_subtraction(BoutReal *result, const BoutReal *lhs,
                                                 const BoutReal *rhs, int nx, int ny,
                                                 int nz);
}

// Provide the C++ wrapper for subtraction of Field3D and Field2D
Field3D operator-(const Field3D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_Field2D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx, localmesh->LocalNy,
                                              localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by subtraction with Field2D
void autogen_Field3D_Field2D_subtraction(BoutReal *lhs, const BoutReal *rhs, int nx,
                                         int ny, int nz);
}

// Provide the C++ operator to update Field3D by subtraction with Field2D
Field3D &Field3D::operator-=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_Field2D_subtraction(&(*this)[i], &rhs[i], fieldmesh->LocalNx,
                                        fieldmesh->LocalNy, fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_BoutReal_multiplication(BoutReal *result,
                                                     const BoutReal *lhs,
                                                     const BoutReal rhs, int len);
}

// Provide the C++ wrapper for multiplication of Field3D and BoutReal
Field3D operator*(const Field3D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_multiplication(
      &result[i], &lhs[i], rhs,
      localmesh->LocalNx * localmesh->LocalNy * localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by multiplication with BoutReal
void autogen_Field3D_BoutReal_multiplication(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field3D by multiplication with BoutReal
Field3D &Field3D::operator*=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_multiplication(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_BoutReal_division(BoutReal *result, const BoutReal *lhs,
                                               const BoutReal rhs, int len);
}

// Provide the C++ wrapper for division of Field3D and BoutReal
Field3D operator/(const Field3D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_division(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by division with BoutReal
void autogen_Field3D_BoutReal_division(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field3D by division with BoutReal
Field3D &Field3D::operator/=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_division(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_BoutReal_addition(BoutReal *result, const BoutReal *lhs,
                                               const BoutReal rhs, int len);
}

// Provide the C++ wrapper for addition of Field3D and BoutReal
Field3D operator+(const Field3D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_addition(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by addition with BoutReal
void autogen_Field3D_BoutReal_addition(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field3D by addition with BoutReal
Field3D &Field3D::operator+=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_addition(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field3D_BoutReal_subtraction(BoutReal *result, const BoutReal *lhs,
                                                  const BoutReal rhs, int len);
}

// Provide the C++ wrapper for subtraction of Field3D and BoutReal
Field3D operator-(const Field3D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field3D_BoutReal_subtraction(&result[i], &lhs[i], rhs,
                                               localmesh->LocalNx * localmesh->LocalNy *
                                                   localmesh->LocalNz);

  result.setLocation(lhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field3D by subtraction with BoutReal
void autogen_Field3D_BoutReal_subtraction(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field3D by subtraction with BoutReal
Field3D &Field3D::operator-=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field3D_BoutReal_subtraction(
        &(*this)[i], rhs, fieldmesh->LocalNx * fieldmesh->LocalNy * fieldmesh->LocalNz);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_Field2D_Field3D_multiplication(BoutReal *result, const BoutReal *lhs,
                                                    const BoutReal *rhs, int nx, int ny,
                                                    int nz);
}

// Provide the C++ wrapper for multiplication of Field2D and Field3D
Field3D operator*(const Field2D &lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx, localmesh->LocalNy,
                                                 localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_Field2D_Field3D_division(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int nx, int ny,
                                              int nz);
}

// Provide the C++ wrapper for division of Field2D and Field3D
Field3D operator/(const Field2D &lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_Field2D_Field3D_addition(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int nx, int ny,
                                              int nz);
}

// Provide the C++ wrapper for addition of Field2D and Field3D
Field3D operator+(const Field2D &lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx, localmesh->LocalNy,
                                           localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_Field2D_Field3D_subtraction(BoutReal *result, const BoutReal *lhs,
                                                 const BoutReal *rhs, int nx, int ny,
                                                 int nz);
}

// Provide the C++ wrapper for subtraction of Field2D and Field3D
Field3D operator-(const Field2D &lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_Field2D_Field3D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx, localmesh->LocalNy,
                                              localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field2D_Field2D_Field2D_multiplication(BoutReal *result, const BoutReal *lhs,
                                                    const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for multiplication of Field2D and Field2D
Field2D operator*(const Field2D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_multiplication(&result[i], &lhs[i], &rhs[i],
                                                 localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by multiplication with Field2D
void autogen_Field2D_Field2D_multiplication(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field2D by multiplication with Field2D
Field2D &Field2D::operator*=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_multiplication(&(*this)[i], &rhs[i],
                                           fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_Field2D_division(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for division of Field2D and Field2D
Field2D operator/(const Field2D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_division(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by division with Field2D
void autogen_Field2D_Field2D_division(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field2D by division with Field2D
Field2D &Field2D::operator/=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_division(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_Field2D_addition(BoutReal *result, const BoutReal *lhs,
                                              const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for addition of Field2D and Field2D
Field2D operator+(const Field2D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_addition(&result[i], &lhs[i], &rhs[i],
                                           localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by addition with Field2D
void autogen_Field2D_Field2D_addition(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field2D by addition with Field2D
Field2D &Field2D::operator+=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_addition(&(*this)[i], &rhs[i],
                                     fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_Field2D_subtraction(BoutReal *result, const BoutReal *lhs,
                                                 const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for subtraction of Field2D and Field2D
Field2D operator-(const Field2D &lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  ASSERT1(localmesh == rhs.getMesh());

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_Field2D_subtraction(&result[i], &lhs[i], &rhs[i],
                                              localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by subtraction with Field2D
void autogen_Field2D_Field2D_subtraction(BoutReal *lhs, const BoutReal *rhs, int len);
}

// Provide the C++ operator to update Field2D by subtraction with Field2D
Field2D &Field2D::operator-=(const Field2D &rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    ASSERT1(fieldmesh == rhs.getMesh());

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_Field2D_subtraction(&(*this)[i], &rhs[i],
                                        fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_BoutReal_multiplication(BoutReal *result,
                                                     const BoutReal *lhs,
                                                     const BoutReal rhs, int len);
}

// Provide the C++ wrapper for multiplication of Field2D and BoutReal
Field2D operator*(const Field2D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_multiplication(
      &result[i], &lhs[i], rhs, localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by multiplication with BoutReal
void autogen_Field2D_BoutReal_multiplication(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field2D by multiplication with BoutReal
Field2D &Field2D::operator*=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_multiplication(&(*this)[i], rhs,
                                            fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) * rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_BoutReal_division(BoutReal *result, const BoutReal *lhs,
                                               const BoutReal rhs, int len);
}

// Provide the C++ wrapper for division of Field2D and BoutReal
Field2D operator/(const Field2D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_division(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by division with BoutReal
void autogen_Field2D_BoutReal_division(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field2D by division with BoutReal
Field2D &Field2D::operator/=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_division(&(*this)[i], rhs,
                                      fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) / rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_BoutReal_addition(BoutReal *result, const BoutReal *lhs,
                                               const BoutReal rhs, int len);
}

// Provide the C++ wrapper for addition of Field2D and BoutReal
Field2D operator+(const Field2D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_addition(&result[i], &lhs[i], rhs,
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by addition with BoutReal
void autogen_Field2D_BoutReal_addition(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field2D by addition with BoutReal
Field2D &Field2D::operator+=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_addition(&(*this)[i], rhs,
                                      fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) + rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field2D_Field2D_BoutReal_subtraction(BoutReal *result, const BoutReal *lhs,
                                                  const BoutReal rhs, int len);
}

// Provide the C++ wrapper for subtraction of Field2D and BoutReal
Field2D operator-(const Field2D &lhs, const BoutReal rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = lhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_Field2D_BoutReal_subtraction(&result[i], &lhs[i], rhs,
                                               localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
// Provide the C function to update Field2D by subtraction with BoutReal
void autogen_Field2D_BoutReal_subtraction(BoutReal *lhs, const BoutReal rhs, int len);
}

// Provide the C++ operator to update Field2D by subtraction with BoutReal
Field2D &Field2D::operator-=(const BoutReal rhs) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {

    Indices i{0, 0, 0};

    checkData(*this);
    checkData(rhs);

    autogen_Field2D_BoutReal_subtraction(&(*this)[i], rhs,
                                         fieldmesh->LocalNx * fieldmesh->LocalNy);

    checkData(*this);

  } else {
    (*this) = (*this) - rhs;
  }
  return *this;
}
extern "C" {
void autogen_Field3D_BoutReal_Field3D_multiplication(BoutReal *result, const BoutReal lhs,
                                                     const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for multiplication of BoutReal and Field3D
Field3D operator*(const BoutReal lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_multiplication(
      &result[i], lhs, &rhs[i],
      localmesh->LocalNx * localmesh->LocalNy * localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_BoutReal_Field3D_division(BoutReal *result, const BoutReal lhs,
                                               const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for division of BoutReal and Field3D
Field3D operator/(const BoutReal lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_division(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_BoutReal_Field3D_addition(BoutReal *result, const BoutReal lhs,
                                               const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for addition of BoutReal and Field3D
Field3D operator+(const BoutReal lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_addition(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy *
                                                localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field3D_BoutReal_Field3D_subtraction(BoutReal *result, const BoutReal lhs,
                                                  const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for subtraction of BoutReal and Field3D
Field3D operator-(const BoutReal lhs, const Field3D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field3D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field3D_BoutReal_Field3D_subtraction(&result[i], lhs, &rhs[i],
                                               localmesh->LocalNx * localmesh->LocalNy *
                                                   localmesh->LocalNz);

  result.setLocation(rhs.getLocation());

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field2D_BoutReal_Field2D_multiplication(BoutReal *result, const BoutReal lhs,
                                                     const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for multiplication of BoutReal and Field2D
Field2D operator*(const BoutReal lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_multiplication(
      &result[i], lhs, &rhs[i], localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field2D_BoutReal_Field2D_division(BoutReal *result, const BoutReal lhs,
                                               const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for division of BoutReal and Field2D
Field2D operator/(const BoutReal lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_division(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field2D_BoutReal_Field2D_addition(BoutReal *result, const BoutReal lhs,
                                               const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for addition of BoutReal and Field2D
Field2D operator+(const BoutReal lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_addition(&result[i], lhs, &rhs[i],
                                            localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}

extern "C" {
void autogen_Field2D_BoutReal_Field2D_subtraction(BoutReal *result, const BoutReal lhs,
                                                  const BoutReal *rhs, int len);
}

// Provide the C++ wrapper for subtraction of BoutReal and Field2D
Field2D operator-(const BoutReal lhs, const Field2D &rhs) {

  Indices i{0, 0, 0};
  Mesh *localmesh = rhs.getMesh();

  Field2D result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_Field2D_BoutReal_Field2D_subtraction(&result[i], lhs, &rhs[i],
                                               localmesh->LocalNx * localmesh->LocalNy);

  checkData(result);
  return result;
}
