#!/bin/python

from __future__ import print_function

try:
    from builtins import range
except:
    pass
try:
    from builtins import object
except:
    pass

from copy import deepcopy as copy

class braces(object):
    def __init__(self,string=""):
        print("%s{"%string)
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("}")

for_gcc=True
autogen_warn = "// This file is autogenerated - see gen_fieldops.py"
print(autogen_warn)
print("""#include <field3d.hxx>
#include <field2d.hxx>
#include <bout/mesh.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
""")
# A class to keep all the data of the different fields
class Field(object):
    # name of the field, e.g. Field3D
    fieldname=''
    # array: dimensions of the field
    dimensions=[]
    # identifier - short version of the field e.g. f3d
    i=''
    #name of this field
    name=None
    def __init__(self,name,dirs,idn):
        self.fieldname=name
        self.dimensions=dirs
        self.i=idn
        self.name=None
    # how to pass data
    #   const: Should it be const?
    #   data:  Pass the raw data?
    def getPass(self,const=True,data=False):
        ret=""
        if const:
            ret+="const "
        if self.i=='real':
            ret+="BoutReal"
        else:
            if data:
                if for_gcc: # use restrict gcc extension
                    ret+='BoutReal * __restrict__'
                else:
                    ret+='BoutReal *'
            else:
                ret+='%s &'%(self.fieldname)
        ret+=" %s"%self.name
        return ret
    # how to get value from field
    #   data: use x,y,z access on raw data?
    #   ptr:  Do return pointer instead of data
    def get(self,data=True,ptr=False):
        if self.i=='real':
            return self.name
        ret=''
        if ptr:
            ret="&"
        if data:
            if self.i=='f2d':
                return ret+'%s[y+x*ny]'%self.name
            elif self.i=='fp':
                return ret+'%s[z+x*nz]'%self.name
            elif self.i=='f3d':
                return ret+'%s[z+nz*(y+ny*x)]'%(self.name)
            else:
                return NotImplemented
        else:
            return ret+"%s[i]"%self.name
    # return the dimensions
    def dims(self):
        return self.dimensions
    def __eq__(self,other):
        try:
            return self.i == other.i
        except:
            return self.i == other
    def __ne__(self,other):
        return not (self==other)
    def __str__(self):
        return "Name: %s\nfieldname: %s\n"%(self.name,self.fieldname)
    def setName(self,name):
        self.name=name

# Declare what fields we currently support:
# Field perp is currently missing
f3d =Field('Field3D'  ,['x','y','z'],'f3d')
f2d =Field('Field2D'  ,['x','y'    ],'f2d')
fp  =Field('FieldPerp',['x',    'z'],'fp')
real=Field('BoutReal' ,[           ],'real')
fields=[f3d,f2d,real]
import sys

# a function to see what field is `larger`. Is used to determine a suitable return type
def returnType(f1,f2):
    if f1==f2:
        return copy(f1)
    elif f1.i == 'real':
        return copy(f2)
    elif f2.i == 'real':
        return copy(f1)
    else:
        return copy(f3d)
def mymin(f1,f2):
    if (len(f1.dimensions) < len(f2.dimensions)):
        return f1
    else:
        return f2

# declare the possible operators + names
ops=['*','/','+','-']
op_names={'*':'mul',
          '/':'div',
          '-':'minus',
          '+':'plus'}

# loop over all fields for lhs and rhs of the operation. Generates the
# not-in-place variants of the operations, returning a new field.
for lhs in fields:
    for rhs in fields:
        if lhs.i == rhs.i == 'real': # we don't have define real real operations
            continue
        rhs=copy(rhs)
        lhs=copy(lhs)
        # if both fields are the same, or one of them is real, we
        # don't need to care what element is stored where, but can
        # just loop directly over everything, using a simple c-style
        # for loop. Otherwise we need x,y,z of the fields.
        if (lhs != rhs and mymin(lhs,rhs).i != 'real'):
            elementwise=True
        else:
            elementwise=False
        # the output of the operation. The `larger` of the two fields.
        out=returnType(rhs,lhs)
        for op in ops:
            opn=op_names[op]
            # *****************************************************************
            # start of the low level function header
            # This function operates on the underlying data
            print(autogen_warn)
            print("// Do the actual %s of %s and %s"%(opn,lhs.fieldname,rhs.fieldname))
            print('void autogen_%s_%s_%s_%s('%(out.fieldname,lhs.fieldname,rhs.fieldname,opn), end=' ')
            out.name='result'
            lhs.name='lhs'
            rhs.name='rhs'
            # the first element (intent out) shouldn't be const, the
            # rest should be (intent in)
            const=False
            fs=[out,lhs,rhs]
            for f in fs:
                print(f.getPass(const=const,data=True),',',end=' ')
                const=True # first not const, but the remaining ones should be
            # depending on how we loop over the fields, we need to now
            # x,y and z, or just the total number of elements
            if elementwise:
                c=''
                for d in out.dimensions:
                    print('%s int n%s'%(c,d), end=' ')
                    c=','
            else:
                print(' int len', end=' ')
            print(')')
            # end of function header.
            # *****************************************************************
            # start of low level function
            # Update the data
            with braces():
                if elementwise:
                    # we need to loop over all dimension of the out file
                    dims= {"n"+x : x for x in out.dims()}
                else:
                    dims={"len":'i'}
                for d,i in dims.iteritems():
                    print('  for (int %s=0;%s<%s;++%s)'%(i,i,d,i))
                with braces():
                    print("    %s = %s %s %s;"%(out.get(data=elementwise),
                                                lhs.get(data=elementwise),
                                                op,
                                                rhs.get(data=elementwise)))
            # end of low level function
            # *****************************************************************
            # beginning of the C++ operator function
            # It takes the Field objects. This function is doing some high
            # level stuff, but does not modify the underlaying data.
            # Stuff done here:
            #  * conserve the mesh
            #  * conserve the field location
            #  * check the input & output data
            #  * allocate data
            #  * get the underlaying data for the low-level operation
            print(autogen_warn)
            print("// Provide the C++ wrapper for %s of %s and %s"%(opn,lhs.fieldname,rhs.fieldname))
            print("%s operator%s(%s,%s)"%(out.fieldname,op,lhs.getPass(),rhs.getPass()))
            with braces():
                print("  Indices i{0,0,0};")
                print("  Mesh * msh = %s.getMesh();"%("lhs" if not lhs.i == 'real' else "rhs"))
                if lhs.i != 'real' and rhs.i != 'real':
                    print("  ASSERT1(msh == rhs.getMesh());")
                print("  %s result(msh);"%out.fieldname)
                print("  result.allocate();")
                print("  checkData(lhs);")
                print("  checkData(rhs);")
                # call the C function to do the work.
                print("  autogen_%s_%s_%s_%s("%(out.fieldname,lhs.fieldname,rhs.fieldname,opn), end=' ')
                for f in fs:
                    print("%s, "%(f.get(data=False,ptr=True)),end=' ')
                m=''
                print('\n             ', end=' ')
                for d in out.dimensions:
                    print(m,"msh->LocalN%s"%d, end=' ')
                    if elementwise:
                        m=','
                    else:
                        m='*'
                print(");")
                # hardcode to only check field location for Field 3D
                if lhs.i == rhs.i == 'f3d':
                    print("#if CHECK > 0")
                    with braces("  if (lhs.getLocation() != rhs.getLocation())"):
                        print('    throw BoutException("Trying to %s fields of different locations. lhs is at %%s, rhs is at %%s!",strLocation(lhs.getLocation()),strLocation(rhs.getLocation()));'%op_names[op])
                    print('#endif')
                # Set out location (again, only for f3d)
                if out.i == 'f3d':
                    if rhs.i == 'f3d':
                        src='rhs'
                    elif lhs.i != 'real':
                        src='lhs'
                    else:
                        src='rhs'
                    print("  result.setLocation(%s.getLocation());"%src)
                # Check result and return
                print("  checkData(result);")
                print("  return result;")
            print()
            print()

# generate the operators for updating the lhs in place
for lhs in fields:
    for rhs in fields:
        # no real real operation
        if lhs.i == rhs.i == 'real':
            continue
        if (lhs != rhs and mymin(lhs,rhs).i != 'real'):
            elementwise=True
        else:
            elementwise=False
        lhs=copy(lhs)
        rhs=copy(rhs)
        out=returnType(rhs,lhs)
        out.name='result'
        lhs.name='lhs'
        rhs.name='rhs'
        if out == lhs:
            for op in ops:
                opn=op_names[op]
                # *************************************************************
                # start of the low level function header
                # This function operates on the underlying data
                print(autogen_warn)
                print("// Provide the C function to update %s by %s with %s"%(lhs.fieldname,opn,rhs.fieldname))
                print('void autogen_%s_%s_%s('%(lhs.fieldname,rhs.fieldname,opn), end=' ')
                const=False
                fs=[lhs,rhs]
                for f in fs:
                    print(f.getPass(data=True,const=const),",", end=' ')
                    const=True
                if elementwise:
                    c=''
                    for d in out.dimensions:
                        print('%s int n%s'%(c,d), end=' ')
                        c=','
                else:
                    print(' int len', end=' ')
                print(')')
                # end of function header
                # *************************************************************
                # beginning of low level function
                # Updating the data in place
                with braces():
                    if elementwise:
                        # we need to loop over all dimension of the out file
                        dims= {"n"+x : x for x in out.dims()}
                    else:
                        dims={"len":'i'}
                    for d,i in dims.iteritems():
                        print('  for (int %s=0;%s<%s;++%s)'%(i,i,d,i))
                    with braces():
                        print("    %s %s= %s;"%(lhs.get(data=elementwise),
                                                op,
                                                rhs.get(data=elementwise)))
                # end of low level function
                # *********************************************************
                # beginning of the C++ operator function
                # It takes the Field objects. This function is doing some high
                # level stuff, but does not modify the underlaying data.
                # Stuff done here:
                #  * conserve the mesh
                #  * conserve the field location
                #  * check the input & output data
                #  * allocate data
                #  * get the underlaying data for the low-level operation
                print(autogen_warn)
                print("// Provide the C++ operator to update %s by %s with %s"%(lhs.fieldname,opn,rhs.fieldname))
                print("%s & %s::operator %s="%(lhs.fieldname,lhs.fieldname,op), end=' ')
                print("(%s)"%(rhs.getPass(const=True)))
                with braces():
                    print("  // only if data is unique we update the field")
                    print("  // otherwise just call the non-inplace version")
                    with braces("  if (data.unique())"):
                        print("    Indices i{0,0,0};")
                        if not rhs.i == 'real':
                            print("    ASSERT1(fieldmesh == rhs.getMesh());")
                        print("    checkData(*this);")
                        print("    checkData(rhs);")
                        print("    autogen_%s_%s_%s(&(*this)[i],"%(lhs.fieldname,rhs.fieldname,opn), end=' ')
                        print(rhs.get(ptr=True,data=False),',',end=' ')
                        m=''
                        print('\n             ', end=' ')
                        for d in out.dimensions:
                            print(m,"fieldmesh->LocalN%s"%d, end=' ')
                            if elementwise:
                                m=','
                            else:
                                m='*'
                        print(");")
                        # if both are f3d, make sure they are in the same location
                        if lhs.i == rhs.i == 'f3d':
                            print("#if CHECK > 0")
                            with braces("  if (this->getLocation() != rhs.getLocation())"):
                                print('    throw BoutException("Trying to %s fields of different locations!");'%op_names[op])
                            print('#endif')
                            print("    checkData(*this);")
                    with braces(" else "): # if data is not unique
                        print("    (*this)= (*this) %s rhs;"%op)
                    print("  return *this;")
                print()
                print()
