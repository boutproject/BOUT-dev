#!/usr/bin/env python3
"""Code-generator for arthimetic operators on Field2Ds/Field3Ds

This program works by generating a "context" dictionary (in
`context_generator`) for each tuple of (result type, left-hand side
type, right-hand side type) which is then substituted into the template
strings. The majority of the logic is within `context_generator`.

The `Field` class provides some helper functions for determining how to
pass a variable by reference or pointer, and how to name arguments in
function signatures. This allows us to push some logic into the
templates themselves.

"""


from __future__ import print_function

try:
    from builtins import object
except ImportError:
    pass

from collections import OrderedDict
from copy import deepcopy as copy
import itertools


# The arthimetic operators
operators = {
    '*': 'mul',
    '/': 'div',
    '+': 'plus',
    '-': 'minus',
}

header = """// This file is autogenerated - see gen_fieldops.py
#include <bout/mesh.hxx>
#include <field2d.hxx>
#include <field3d.hxx>
#include <globals.hxx>
#include <interpolation.hxx>
"""

for_loop_statement_template = (
    "  for (int {index}=0; {index} < {dimension}; ++{index})\n")

# Template for `a = b op c`
non_compound_template = """
// Do the actual {operator_name} of {lhs} and {rhs}
void autogen_{out}_{lhs}_{rhs}_{operator_name}(
    {out.passBoutRealPointer}, const {lhs.passBoutRealPointer},
    const {rhs.passBoutRealPointer}, {low_level_length_arg}) {{
  {for_loop} {{
    {result_op} = {lhs_op} {operator} {rhs_op};
  }}
}}

// Provide the C++ wrapper for {operator_name} of {lhs} and {rhs}
{out} operator{operator}(const {lhs.passByReference}, const {rhs.passByReference}) {{
  Indices i{{0, 0, 0}};
  Mesh *localmesh = {mesh_source}.getMesh();
  {mesh_equality_assert}
  {out} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);
  autogen_{out}_{lhs}_{rhs}_{operator_name}(
      {out.getPointerToData}, {lhs.getPointerToData}, {rhs.getPointerToData},
      {non_compound_length_arg});
  {non_compound_location_check}
  {non_compound_location_set}
  checkData(result);
  return result;
}}
"""

# Helper templates to be composed with non_compound_template
location_check_template = """#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {{
    throw BoutException(
        "Trying to {operator_name} fields of different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }}
#endif"""
location_set_template = "result.setLocation({location_source}.getLocation());"

# Template for `a op= b`
compound_template = """
// Provide the C function to update {lhs} by {operator_name} with {rhs}
void autogen_{lhs}_{rhs}_{operator_name}(
    {lhs.passBoutRealPointer}, const {rhs.passBoutRealPointer}, {low_level_length_arg}) {{
  {for_loop} {{
       {lhs_op} {operator}= {rhs_op};
    }}
}}

// Provide the C++ operator to update {lhs} by {operator_name} with {rhs}
{lhs} &{lhs}::operator{operator}=(const {rhs.passByReference}) {{
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {{
    Indices i{{0, 0, 0}};
    {compound_mesh_equality_assert}
    checkData(*this);
    checkData(rhs);
    autogen_{lhs}_{rhs}_{operator_name}(&(*this)[i], {rhs.getPointerToData},
                                  {compound_length_arg});
    {compound_location_check}
  }} else {{
    (*this) = (*this) {operator} rhs;
  }}
  return *this;
}}
"""

# Helper template to be composed with compound_template
compound_location_check_template = """#if CHECK > 0
  if (this->getLocation() != rhs.getLocation()) {{
    throw BoutException("Trying to {operator_name} fields of different locations!");
  }}
#endif
checkData(*this);
"""


class Field(object):
    """A class to keep all the data of the different fields
    """

    def __init__(self, field_type, dimensions, name=None):
        # C++ type of the field, e.g. Field3D
        self.field_type = field_type
        # array: dimensions of the field
        self.dimensions = dimensions
        # name of this field
        self.name = name

    @property
    def passByReference(self):
        """Returns "Type& name", except if field_type is BoutReal,
        in which case just returns "Type name"

        """
        return "{self.field_type}{ref} {self.name}".format(
            self=self, ref="&" if self.field_type != "BoutReal" else "")

    @property
    def passBoutRealPointer(self):
        """Returns "BoutReal* name", except if field_type is BoutReal,
        in which case just returns "BoutReal name"

        Also adds "__restrict__" attribute if `for_gcc` is True
        """
        return "BoutReal {ref}{restrict} {self.name}".format(
            self=self, ref="*" if self.field_type != "BoutReal" else "",
            restrict="__restrict__" if for_gcc and self.field_type != "BoutReal" else "")

    @property
    def getPointerToData(self):
        """Returns a pointer to the underlying data, e.g. `&Field3D[i]`,
        except for plain BoutReals"""
        if self.field_type == 'BoutReal':
            return self.name
        return "&{}[i]".format(self.name)

    def getElement(self, data=True):
        """Get an element in the field, either using C-loop style index (default),
        or with an `Indices` object

        """

        if self.field_type == 'BoutReal':
            return self.name
        if data:
            if self.field_type == 'Field2D':
                index = "y + x*ny"
            elif self.field_type == 'FieldPerp':
                index = "z + x*nz"
            elif self.field_type == 'Field3D':
                index = "z + nz*(y + ny*x)"
            else:
                raise ValueError("Unexpected field_type")
        else:
            index = "i"
        return "{name}[{index}]".format(name=self.name, index=index)

    def __eq__(self, other):
        try:
            return self.field_type == other.field_type
        except AttributeError:
            return self.field_type == other

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "Field({}, {}, {})".format(self.field_type, self.dimensions, self.name)

    def __str__(self):
        return self.field_type


# Declare what fields we currently support:
# Field perp is currently missing
field3D = Field('Field3D', ['x', 'y', 'z'])
field2D = Field('Field2D', ['x', 'y'])
boutreal = Field('BoutReal', [])
fields = [field3D, field2D, boutreal]


def returnType(f1, f2):
    """Determine a suitable return type, by seeing which field is 'larger'.

    """
    if f1 == f2:
        return copy(f1)
    elif f1 == 'BoutReal':
        return copy(f2)
    elif f2 == 'BoutReal':
        return copy(f1)
    else:
        return copy(field3D)


def context_generator(out, lhs, rhs):
    """
    Generate the context to be substituted into the templates

    Inputs
    ======
    out: Field for the result
    lhs: Field for the left-hand side input argument
    rhs: Field for the right-hand side input argument
    """

    # If both fields are the same, or one of them is real, we
    # don't need to care what element is stored where, but can
    # just loop directly over everything, using a simple c-style
    # for loop. Otherwise we need x,y,z of the fields.
    elementwise = lhs != rhs and lhs != 'BoutReal' and rhs != 'BoutReal'

    # The length argument for the low-level helper function: either each
    # dimension individually, or the total number of elements
    if elementwise:
        low_level_length_arg = ",".join(["int n{}".format(d) for d in out.dimensions])
        dims = OrderedDict([("n" + x, x) for x in out.dimensions])
    else:
        low_level_length_arg = " int len"
        dims = {"len": 'i'}

    # This produces either a triple-nested loop, or a single loop over
    # all elements (if elementwise is False)
    for_loop = ""
    for dimension, index in dims.items():
        for_loop += for_loop_statement_template.format(dimension=dimension,
                                                       index=index)

    # Check that the mesh is the same for all fields
    mesh_equality_assert = ""
    compound_mesh_equality_assert = ""
    if lhs != 'BoutReal' and rhs != 'BoutReal':
        mesh_equality_assert = "ASSERT1(localmesh == rhs.getMesh());"
        compound_mesh_equality_assert = "ASSERT1(fieldmesh == rhs.getMesh());"

    # Either total number of elements, or size of each dimension separately
    m = ',' if elementwise else '*'
    non_compound_length_arg = m.join(["localmesh->LocalN{}".format(d) for d in out.dimensions])
    compound_length_arg = m.join(["fieldmesh->LocalN{}".format(d) for d in out.dimensions])

    # Only check field location for Field3D
    non_compound_location_check = ""
    compound_location_check = ""
    if lhs == rhs == 'Field3D':
        non_compound_location_check = location_check_template.format(operator_name=operator_name)
        compound_location_check = compound_location_check_template.format(
            operator_name=operator_name)

    # Set location for result (again, only for Field3d)
    non_compound_location_set = ""
    if out == 'Field3D':
        source = "rhs" if rhs == "Field3D" else "lhs"
        non_compound_location_set = location_set_template.format(location_source=source)

    mesh_source = "lhs" if lhs != 'BoutReal' else "rhs"

    template_args = {
        'out': out,
        'lhs': lhs,
        'rhs': rhs,

        'operator': operator,
        'operator_name': operator_name,

        'low_level_length_arg': low_level_length_arg,
        'non_compound_length_arg': non_compound_length_arg,
        'compound_length_arg': compound_length_arg,

        'for_loop': for_loop,

        'mesh_equality_assert': mesh_equality_assert,
        'compound_mesh_equality_assert': compound_mesh_equality_assert,

        'mesh_source': mesh_source,
        'non_compound_location_check': non_compound_location_check,
        'non_compound_location_set': non_compound_location_set,
        'compound_location_check': compound_location_check,

        'result_op': out.getElement(data=elementwise),
        'lhs_op': lhs.getElement(data=elementwise),
        'rhs_op': rhs.getElement(data=elementwise),
    }

    return template_args


if __name__ == "__main__":
    for_gcc = True
    print(header)

    for lhs, rhs in itertools.product(fields, fields):
        # We don't have define real real operations
        if lhs == rhs == 'BoutReal':
            continue
        rhs = copy(rhs)
        lhs = copy(lhs)

        # The output of the operation. The `larger` of the two fields.
        out = returnType(rhs, lhs)
        out.name = 'result'
        lhs.name = 'lhs'
        rhs.name = 'rhs'

        for operator, operator_name in operators.items():
            template_args = context_generator(out, lhs, rhs)
            print(non_compound_template.format(**template_args))

            if out == lhs:
                print(compound_template.format(**template_args))
