// Do the actual {{operator_name}} of {{lhs}} and {{rhs}}
void autogen_{{out}}_{{lhs}}_{{rhs}}_{{operator_name}}(
  {{out.passBoutRealPointer}}, const {{lhs.passBoutRealPointer}},
  const {{rhs.passBoutRealPointer}}, {{length_arg}}) {

  {% for dimension, index in dims.items() %}
     for (int {{index}}=0; {{index}} < {{dimension}}; ++{{index}})
  {% endfor %}
       {
         {{out.getElement(elementwise)}} =
           {{lhs.getElement(elementwise)}} {{operator}} {{rhs.getElement(elementwise)}};
       }
}

// Provide the C++ wrapper for {{operator_name}} of {{lhs}} and {{rhs}}
{{out}} operator{{operator}}(const {{lhs.passByReference}}, const {{rhs.passByReference}}) {
  {% if lhs == rhs == "Field3D" %}
#if CHECK > 0
  if (lhs.getLocation() != rhs.getLocation()) {
    throw BoutException(
        "Error in operator{{operator}}({{lhs}}, {{rhs}}): fields at different locations. lhs is at %s, rhs is at %s!",
        strLocation(lhs.getLocation()), strLocation(rhs.getLocation()));
  }
#endif
  {% endif %}

  Indices i{0, 0, 0};
  Mesh *localmesh = {{"lhs" if lhs.field_type != "BoutReal" else "rhs"}}.getMesh();

  {% if lhs != "BoutReal" and rhs != "BoutReal" %}
    ASSERT1(localmesh == rhs.getMesh());
  {% endif %}

  {{out.field_type}} result(localmesh);
  result.allocate();
  checkData(lhs);
  checkData(rhs);

  autogen_{{out}}_{{lhs}}_{{rhs}}_{{operator_name}}(
    {{out.getPointerToData}}, {{lhs.getPointerToData}},
    {{rhs.getPointerToData}},
    {% if elementwise %}
      {{ non_compound_length_dims | join(', ')}}
    {% else %}
      {{ non_compound_length_dims | join('* ')}}
    {% endif %}
    );

  {% if out == 'Field3D' %}
    result.setLocation({{"rhs" if rhs == "Field3D" else "lhs"}}.getLocation());
  {% endif %}

  checkData(result);
  return result;
}

{% if out.field_type == lhs.field_type %}
// Provide the C function to update {{lhs}} by {{operator_name}} with {{rhs}}
void autogen_{{lhs}}_{{rhs}}_{{operator_name}}(
  {{lhs.passBoutRealPointer}}, const {{rhs.passBoutRealPointer}}, {{length_arg}}) {

  {% for dimension, index in dims.items() %}
     for (int {{index}}=0; {{index}} < {{dimension}}; ++{{index}})
  {% endfor %}
      {
        {{lhs.getElement(elementwise)}} {{operator}}= {{rhs.getElement(elementwise)}};
      }
}

// Provide the C++ operator to update {{lhs}} by {{operator_name}} with {{rhs}}
{{lhs}} &{{lhs}}::operator{{operator}}=(const {{rhs.passByReference}}) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    {% if lhs == rhs == "Field3D" %}
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException(
        "Error in {{lhs}}::operator{{operator}}=({{rhs}}): fields at different locations. lhs is at %s, rhs is at %s!",
        strLocation(this->getLocation()), strLocation(rhs.getLocation()));
    }
#endif
    {% endif %}

    Indices i{0, 0, 0};

    {% if lhs != "BoutReal" and rhs != "BoutReal" %}
      ASSERT1(fieldmesh == rhs.getMesh());
    {% endif %}

    checkData(*this);
    checkData(rhs);

    autogen_{{lhs}}_{{rhs}}_{{operator_name}}(&(*this)[i],
      {{rhs.getPointerToData}},
    {% if elementwise %}
      {{ compound_length_dims | join(', ')}}
    {% else %}
      {{ compound_length_dims | join('* ')}}
    {% endif %}
    );

    checkData(*this);

  } else {
    (*this) = (*this) {{operator}} rhs;
  }
  return *this;
}
{% endif %}
