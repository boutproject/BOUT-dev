// Provide the C++ wrapper for {{operator_name}} of {{lhs}} and {{rhs}}
{{out}} operator{{operator}}(const {{lhs.passByReference}}, const {{rhs.passByReference}}) {
  {% if lhs in ["Field3D", "Field2D"] and rhs in ["Field3D", "Field2D"] %}
#if CHECK > 0
  if ({{lhs.name}}.getLocation() != {{rhs.name}}.getLocation()) {
    throw BoutException(
        "Error in operator{{operator}}({{lhs}}, {{rhs}}): fields at different locations. lhs is at %s, rhs is at %s!",
        strLocation({{lhs.name}}.getLocation()), strLocation({{rhs.name}}.getLocation()));
  }
#endif
  {% endif %}

  Mesh *localmesh = {{lhs.name if lhs.field_type != "BoutReal" else rhs.name}}.getMesh();

  {% if lhs != "BoutReal" and rhs != "BoutReal" %}
    ASSERT1(localmesh == {{rhs.name}}.getMesh());
  {% endif %}

  {{out.field_type}} {{out.name}}(localmesh);
  {{out.name}}.allocate();
  checkData({{lhs.name}});
  checkData({{rhs.name}});

  {{region_loop}}(localmesh->getRegion{{out.region_type}}({{region_name}}),{{index_var}},
	{{out.index}} = {{lhs.index}} {{operator}} {{rhs.index}};
	);

  {% if out in ["Field3D", "Field2D"] %}
    {{out.name}}.setLocation({{rhs.name if rhs in ["Field3D","Field2D"] else lhs.name}}.getLocation());
  {% endif %}

  checkData({{out.name}});
  return {{out.name}};
}

{% if out.field_type == lhs.field_type %}
// Provide the C++ operator to update {{lhs}} by {{operator_name}} with {{rhs}}
{{lhs}} &{{lhs}}::operator{{operator}}=(const {{rhs.passByReference}}) {
  // only if data is unique we update the field
  // otherwise just call the non-inplace version
  if (data.unique()) {
    {% if lhs in ["Field3D", "Field2D"] and rhs in ["Field3D", "Field2D"] %}
#if CHECK > 0
    if (this->getLocation() != rhs.getLocation()) {
      throw BoutException(
        "Error in {{lhs}}::operator{{operator}}=({{rhs}}): fields at different locations. lhs is at %s, rhs is at %s!",
        strLocation(this->getLocation()), strLocation({{rhs.name}}.getLocation()));
    }
#endif
    {% endif %}

    {% if lhs != "BoutReal" and rhs != "BoutReal" %}
      ASSERT1(fieldmesh == {{rhs.name}}.getMesh());
    {% endif %}

    checkData(*this);
    checkData({{rhs.name}});

      {{region_loop}}(fieldmesh->getRegion{{lhs.region_type}}({{region_name}}),{{index_var}},
	(*this)[{{index_var}}] {{operator}}= {{rhs.index}};
	);			 

    checkData(*this);

  } else {
    (*this) = (*this) {{operator}} {{rhs.name}};
  }
  return *this;
}
{% endif %}
