#!/usr/bin/env python3

import boutcore
import numpy as np
from boutdata import collect

errorlist=""

boutcore.init("-d data -q -q -q")#+" -f BOUT.settings")
n=collect("f2d",path='input',tind=-1,yguards=True)
print(n.shape)
T=collect("f3d",path='input',tind=-1,yguards=True)
print(n.shape)

print("initialized mesh")
mesh=boutcore.Mesh.getGlobal();
#mesh=boutcore.Mesh()
print("initialized mesh")

dens=boutcore.Field3D.fromMesh(mesh)
dens[:,:,:]=n
#temp=boutcore.Field3D.fromMesh(mesh)
#temp.setAll(T.reshape(T.shape[1:]))
temp=boutcore.Field3D.fromCollect("f3d",path="input")
pres=dens+temp
p=pres.get()
pn=(n+T)
if not ((p==pn).all()):
    errorlist+="addition not working\n"
pres=dens*temp*1
p=pres.getAll()
print(n,T)
pn=n*T
pn=pn.reshape(p.shape)
if not ((p==pn).all()):
    errorlist+="multiplication not working\n"
print(p.shape)
print(pn.shape)
diff=boutcore.DDZ(pres)
boutcore.interp_to(diff,"CELL_YLOW")
shapes=[]
errors=[]
#nzs=[4 , 8, 16,32,64,128,256,512,1024,2048,4096,8192,16000,32000,64000,128e3,2**]
mmax=7
start=6
doPlot=False
nzs=np.logspace(start,mmax,num=mmax-start+1,base=2)
for nz in nzs:
    boutcore.setOption("meshz:nz","%d"%nz)
    boutcore.setOption("meshz:dz","2*Pi/%d"%nz)#%.30g"%(2*np.pi/nz))# better pass calculation to bout ...
    mesh=boutcore.Mesh(OptionSection="meshz")
    f=boutcore.create3D("sin(z)",mesh)
    sim=boutcore.DDZ(f)
    ana=boutcore.create3D("cos(z)",mesh)
    err=sim-ana
    err=np.max(np.abs(err.getAll()))
    errors.append(err)
if doPlot:
    from matplotlib import pyplot as plt
    plt.plot(1/np.array(nzs),errors,'-o')
    plt.show()
errc=np.log(errors[-2]/errors[-1])
difc=np.log(nzs[-1]/nzs[-2])
conv=errc/difc
if 1.9 < conv < 2.1:
    print("The convergence is: %f"%conv)
else:
    errorlist+="DDZ is not working\n"

if errorlist != "":
    print("Found errors:\n%s"%errorlist)
    exit(1)


def rhs(time):
    #print("Whaa")
    n_ddt=dens.ddt()
    n_ddt[:,:,:]=dens*0
    n_ddt+=1

model=boutcore.PhysicsModelBase()
model.setRhs(rhs)
model.solve_for(n=dens)
model.solve()


# class MyModel(boutcore.PhysicsModel):
#     def init(self,restart):
#         print("setting to sin")
#         self.n=boutcore.create3D("sin(x)")
#         self.solve_for(dens=self.n)
#     def rhs(self,time):
#         self.n.ddt(boutcore.DDX(self.n))

# model=MyModel()
# #model.myinit(True)
# model.solve()
# # model2=MyModel()
# # model2.init()
# # model2.solve()
# #boutcore.finalise()
