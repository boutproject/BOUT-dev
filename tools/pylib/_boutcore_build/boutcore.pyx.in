#!/bin/bash
# parse bout-config to extract appropriate flags
inc_dirs=
flags=
libs=
lib_dirs=
ldflags=
for fl in $(bout-config --cflags)
do
    if test ".${fl:0:2}" == ".-I"
    then
        inc_dirs+=" ${fl:2}"
    else
        flags+=" $fl"
    fi
done
for fl in $(bout-config --libs)
do
    s=${fl:0:2}
    if test ".$s" == ".-L"
    then
        lib_dirs+=" ${fl:2}"
    elif test ".$s" == ".-l"
    then
        libs+=" ${fl:2}"
    else
	ldflags+=" $fl"
    fi
done

# needed sometimes to add include dir ...
python_dirs=$($PY -c "import site; print('\n'.join(site.getsitepackages()))")
numpyheader=$(for d in $python_dirs
              do
                  find $d|grep numpy/arrayobject.h
              done)
inc_dirs="${numpyheader%/*/*} $inc_dirs"

# Main file
cat <<EOF
# distutils: language=c++
# distutils: include_dirs = $inc_dirs
# distutils: libraries = $libs
# distutils: library_dirs = $lib_dirs
# distutils: sources = helper.cxx
# distutils: extra_compile_args = $flags
EOF
if test ".${ldflags}" != "."
then
    echo "# distutils: extra_link_args = $ldflags"
fi
cat <<EOF

# cython: binding=True

cimport boutcpp as c
import numpy as np
cimport numpy as np
#import atexit
cimport resolve_enum as benum
from libc.stdlib cimport malloc, free
import copy
EOF

# make a list of the format "nx, ny, nz" or something similar
# 'n$d' gets expaneded to "nx, ny, nz"
# 'f[$i]' to "f[0], f[1], f[2]"
# NB: use single ticks to prevent to early expansion
makelist () {
    format="$1"
    test $# -gt 1 &&
	spacing="$2" || spacing=", "
    start="" ; i=0
    for d in ${dims[@]} ; do
	echo -n "$start" ;
	eval echo -n "\"$format\""
	start="$spacing" ; i=$(( i + 1 ))
    done ; }

for ftype in "Field3D" "Field2D"
do
  if [ $ftype = "Field3D" ]; then
    fdd="f3d"
    ndim=3
    dims=(x y z)
    ftypeFromObj="f3dFromObj"
  elif [ $ftype = "Field2D" ]; then
    fdd="f2d"
    ndim=2
    dims=(x y)
    ftypeFromObj="f2dFromObj"
  else
    echo "Error, unimplemented ftype"
    exit 1
  fi
cat <<EOF

cdef extern from "helper.h":
    void c_set_${fdd}_all(c.$ftype * f, double * data)
    void c_get_${fdd}_all(c.$ftype * f, double * data)
    void c_set_${fdd}_all_(c.$ftype * f, double data)
    void c_set_${fdd}_from_${fdd}(c.$ftype * f, c.$ftype * f)
EOF
indices=$(makelist 'int ${d}s, int ${d}e, int d${d}')
cat <<EOF
    void c_get_${fdd}_part(c.${ftype} * f, double * data, $indices)
    void c_set_${fdd}_part(c.${ftype} * f, double * data, $indices)
    void c_set_${fdd}_part_(c.${ftype} * f, double data, $indices)
EOF
for f in "add:+" "mul:*" "truediv:/" "div:/" "sub:-"
do
    n=${f%:*}
    echo "    c.$ftype * f$n( c.$ftype*, c.$ftype*) except +"
    echo "    c.$ftype * f$n( c.$ftype*, double) except +"
    echo "    c.$ftype * f$n( double, c.$ftype*) except +"
    echo "    void fi$n( c.$ftype*, c.$ftype*) except +"
    echo "    void fi$n( c.$ftype*, double) except +"
    if [ $ftype = "Field3D" ]; then
        echo "    c.Field3D * f$n( c.Field2D*, c.Field3D*) except +"
        echo "    c.Field3D * f$n( c.Field3D*, c.Field2D*) except +"
        echo "    void fi$n( c.Field3D*, c.Field2D*) except +"
    fi
done
cat <<EOF
    c.$ftype c_minus( c.$ftype )

cdef $ftype ${fdd}FromObj(c.$ftype i):
    f=$ftype()
    f.cobj=new c.$ftype(<const c.$ftype & ?>i)
    return f

cdef $ftype ${fdd}FromPtr(c.$ftype * i):
    f=$ftype()
    f.cobj=i
    f.isSelfOwned=False
    return f

cdef class $ftype:
    """
    The $ftype class
    """
    cdef c.$ftype * cobj
    cdef c.bool isSelfOwned
    @classmethod
    def fromMesh(cls,mesh=None):
        """
        Create a $ftype.

        Parameters
        ----------
        mesh : Mesh, optional
             The mesh of the $ftype. If None, use global mesh
        """
        checkInit()
        $fdd=$ftype()
        if mesh is None:
            mesh=Mesh.getGlobal()
        $fdd.cobj=new c.$ftype((<Mesh?>mesh).cobj)
        return $fdd
    @classmethod
    def fromCollect(cls,name,tind=-1,mesh=None,ignoreDataType=False, **kwargs):
        """
        Create a $ftype from reading in a datafile via collect.

        Parameters
        ----------
        tind : int
            time slice to read
        mesh : Mesh
            if not defined, use global mesh
        ignoreDataType : bool
            Do not fail if data is not float64
        **kwargs
            remaining arguments are passed to collect
        """
        checkInit()
        from boutdata.collect import collect, dimensions

        if mesh is None:
            mesh=Mesh.getGlobal()
        f=cls.fromMesh(mesh)
        # Make it MPI aware
        cdef c.Mesh* mesh_ = (<Mesh?>mesh).cobj
        nxpe=mesh_.getNXPE()
        nype=mesh_.getNYPE()
        if (nxpe):
            if "xind" in kwargs.keys():
                raise RuntimeError("Do not support xind slicing with MPI")
            nxi=mesh_.getXProcIndex()
            nxg=mesh_.xstart
            nx=mesh_.LocalNx
            nx_=nx-2*nxg
            xstart=nx_*nxi
            kwargs['xind']=[xstart,xstart+nx]
        if (nype):
            if "yind" in kwargs.keys():
                raise RuntimeError("Do not support yind slicing with MPI")
            nyi=mesh_.getYProcIndex()
            nyg=mesh_.ystart
            ny=mesh_.LocalNy
            ny_=ny-2*nyg
            ystart=ny_*nyi
            kwargs['yind']=[ystart,ystart+ny]
        data=collect(name,yguards=True,tind=tind,**kwargs)
        dims=dimensions(name,**{k:v for k,v in kwargs.items() if k in ['path','prefix']})
        if dims[0] == 't':
            data=data.reshape(data.shape[1:])
        if len(data.shape) != ${ndim}:
            raise TypeError("Expected ${ndim}D data")
        try:
            loc=data.attributes['cell_location']
        except KeyError:
            pass
        else:
            f.setLocation(loc)
        f.setAll(data,ignoreDataType=ignoreDataType)
        return f

    @classmethod
    def fromBoutOutputs(cls,outputs,name,tind=-1,mesh=None,ignoreDataType=False):
        """
        Create a $ftype from reading in a datafile via collect.

        Parameters
        ----------
        outputs : BoutOutputs
            object to read from
        tind : int
            time slice to read
        mesh : Mesh
            if not defined, use global mesh
        ignoreDataType : bool
            Do not fail if data is not float64
        **kwargs
            remaining arguments are passed to collect
        """
        checkInit()

        if mesh is None:
            mesh=Mesh.getGlobal()
        f=cls.fromMesh(mesh)
        # Make it MPI aware
        cdef c.Mesh* mesh_ = (<Mesh?>mesh).cobj
        nxpe=mesh_.getNXPE()
        nype=mesh_.getNYPE()
        # save original _kwargs from outputs so we can restore them later
        orig_kwargs = copy.copy(outputs._kwargs)
        kwargs = outputs._kwargs
        kwargs['xguards']=True
        kwargs['yguards']=True
        kwargs['tind']=tind
        if (nxpe):
            if "xind" in kwargs.keys():
                raise RuntimeError("Do not support xind slicing with MPI")
            nxi=mesh_.getXProcIndex()
            nxg=mesh_.xstart
            nx=mesh_.LocalNx
            nx_=nx-2*nxg
            xstart=nx_*nxi
            kwargs['xind']=[xstart,xstart+nx]
        if (nype):
            if "yind" in kwargs.keys():
                raise RuntimeError("Do not support yind slicing with MPI")
            nyi=mesh_.getYProcIndex()
            nyg=mesh_.ystart
            ny=mesh_.LocalNy
            ny_=ny-2*nyg
            ystart=ny_*nyi
            kwargs['yind']=[ystart,ystart+ny]
        data=outputs[name]
        dims=outputs.dimensions[name]
        # restore original _kwargs
        outputs._kwargs=orig_kwargs
        if dims[0] == 't':
            data=data.reshape(data.shape[1:])
        if len(data.shape) != ${ndim}:
            raise TypeError("Expected ${ndim}D data")
        try:
            loc=data.attributes['cell_location']
        except KeyError:
            pass
        else:
            f.setLocation(loc)
        f.setAll(data,ignoreDataType=ignoreDataType)
        return f

    def __cinit__(self,$ftype obj=None):
        self.cobj=NULL
        if obj:
            self.cobj=obj.cobj
        self.isSelfOwned=True
        #self.cobj = (<c.$ftype * ?> cobj_)
        #if self.cobj == NULL:
        #    raise MemoryError('Not enough memory, allocation failed.')

    def set(self,data,ignoreDataType=False):
        """
        Set all data of the $ftype

        Parameters
        ----------
        data : array_like
            The data to be set
        ignoreDataType : bool
            Ignore if data is off different type to BoutReal
        """
        return self.setAll(data,ignoreDataType)

    def setAll(self,data,ignoreDataType=False):
        """
        Set all data of the $ftype

        Parameters
        ----------
        data : array_like
            The data to be set
        ignoreDataType : bool
            Ignore if data is off different type to BoutRealxx
        """
EOF

echo -n "        dims=["
makelist 'self.cobj.getN$d()'
echo "]"
zeros=$(makelist "0")
nxlist=$(makelist 'n$d')

cat <<EOF
        if isinstance(data, (int, float)):
            data=np.zeros(dims)+data
        if data.dtype != np.dtype('float64'):
            if ignoreDataType:
                data=data.astype('float64')
            else:
                raise TypeError("expected float64 data, but got %s.\nThis can be ignored by adding ignoreDataType=True as argument"%data.dtype)
        dims_in=self._checkDims(dims,data.shape)
        cdef np.ndarray[double, mode="c", ndim=$ndim] data_ = np.ascontiguousarray(data)
        c_set_${fdd}_all(self.cobj,&data_[$zeros])

    def get(self):
        """
        Get all data of the $ftype

        Returns
        -------
        array
             A ${ndim}D numpy array with the data of the $ftype
        """
        return self.getAll()

    def getAll(self):
        """
        Get all data of the $ftype

        Returns
        -------
        array
            A ${ndim}D numpy array with the data of the $ftype
        """
        nx=self.cobj.getNx()
        ny=self.cobj.getNy()
        nz=self.cobj.getNz()
        #print(nx,ny,nz)
        cdef np.ndarray[double, mode="c", ndim=$ndim] data_ = np.ascontiguousarray(np.zeros(($nxlist)))
        c_get_${fdd}_all(self.cobj,&data_[$zeros]);
        return data_

    def setLocation(self,location):
        """
        Set the location of the $ftype
        This does not do any modification of the data.

        Parameters
        ----------
        location : string
             The location to be set, e.g. "YLOW" or "CELL_YLOW" are supported.
        """
        cdef benum.CELL_LOC location_ = benum.resolve_cell_loc(location)
        self.cobj[0].setLocation(location_)
        return self

    def getLocation(self):
        """
        Get the location of the $ftype

        Returns
        -------
        string
            Representation of the field's location.
        """
        cdef benum.CELL_LOC loc = self.cobj[0].getLocation()
        return _resolve_inv_cell_loc(loc)

    def ddt(self,val=None):
        """
        Get or set the time derivative

        Returns
        -------
        $ftype
            the $ftype's time derivative

        Parameters
        ----------
        val : $ftype, optional
             If set, set the time derivative to val
        """
        if val:
            c_set_${fdd}_from_${fdd}(&c.ddt(self.cobj[0]),(<$ftype?>val).cobj)
        return ${fdd}FromPtr(&c.ddt(self.cobj[0]))

    def __neg__(self):
        """

        Returns
        -------
        $ftype
            negative of the Field
        """
        return ${fdd}FromObj(c_minus(self.cobj[0]))

    def isAllocated(self):
        """
        Check if the $ftype has its own datablock allocated

        Returns
        -------
        bool
            whether the Field is allocated
        """
        return self.cobj.isAllocated()

    def __getitem__(self,slices):
        """
        Get data from the $ftype
        Supports full ${ndim}D slicing support.
        Partially slicing is currently not supported.

        Parameters
        ----------
        slices: tuple_like, slice
            List of slice objects, which shall be returned. Must contain ${ndim} slice objects

        Returns
        -------
        array
            Numpy array of the requested data
        """
        if len(slices)!=$ndim:
            raise IndexError("This is a ${ndim}D object, but got %d slics"%len(slices))
        inds=_resolve_slices(slices,
                            [$(makelist 'self.cobj.getN$d()')])
        dims=[]
        for i in inds:
            dims.append((i[1]-i[0])//i[2])
        cdef np.ndarray[double, mode="c", ndim=$ndim] data_ = np.ascontiguousarray(np.zeros(dims))
        c_get_${fdd}_part(self.cobj,&data_[$zeros], $(makelist 'inds[$i][0],inds[$i][1],inds[$i][2]' ));
        return data_

    def __setitem__(self,slices,data_):
        """
        Parameters
        ----------
        slices: tuple_like, slice
            slice objects of the data to be set. Must contain $ndim slice objects
        data : array_like
            Values to be set. Must be ${ndim}D and match the size of the slicing object.
        """
        if len(slices)!=${ndim}:
            raise IndexError("This is a ${ndim}D object!")
        dims=[]
        import numbers
        inds=_resolve_slices(slices,
                            [$(makelist 'self.cobj.getN$d()')])
        if isinstance(data_,${ftype}):
            # get all to get a numpy array
            data_=data_[$(makelist ':')]
        elif isinstance(data_,numbers.Number):
            c_set_${fdd}_part_(self.cobj,<double>data_,$(makelist 'inds[$i][0],inds[$i][1],inds[$i][2]'))
            return
        try:
            dims_in=data_.shape
        except:
            raise TypeError("Expected a $ftype or a numpy array")
        for i in inds:
            dims.append((i[1]-i[0])//i[2])
        dims_in=self._checkDims(dims,dims_in)
        cdef np.ndarray[double, mode="c", ndim=$ndim] data__ = np.ascontiguousarray(data_)
        c_set_${fdd}_part(self.cobj,&data__[$(makelist 0)],$(makelist 'inds[$i][0],inds[$i][1],inds[$i][2]'));

    def _checkDims(self,dims,dims_in):
        if len(dims_in) > $ndim:
            raise IndexError("This is a ${ndim}D object, but got %d dimensions"%len(dims_in))
        if len(dims_in) < $ndim:
            len_dims=len([1 for d in dims if d>1])
            if len(dims_in) != len_dims:
                raise IndexError("This is a ${ndim}D object, but got %d dimensions"%len(dims_in))
            dims_in_new=[]
            k=0
            for i in range($ndim):
                if (dims[i]==1):
                    dims_in_new.append(1)
                else:
                    dims_in_new.append(dims_in[k])
                    k+=1
            dims_in=dims_in_new
        for i in range($ndim):
            if dims[i] != dims_in[i]:
                raise IndexError("Expected %s but got %s."%(dims,dims_in))

EOF
for f in "add:+" "mul:*" "truediv:/" "div:/" "sub:-"
do
    n=${f%:*}
    #o=${f#*:}
    cat <<EOF
    def __${n}__(self,other):
        #print("call __${n}__")
        fu=$ftype()
        import numbers
        if isinstance(self,$ftype) and isinstance(other,$ftype):
            fu.cobj=f$n((<$ftype?>self).cobj , (<$ftype?>other).cobj)
        elif isinstance(self,$ftype) and isinstance(other, numbers.Number):
            fu.cobj=f$n((<$ftype?>self).cobj , (<double?>float(other)))
        elif isinstance(self,numbers.Number) and isinstance(other, $ftype):
            fu.cobj=f$n(<double?>float(self),(<$ftype?>other).cobj)
EOF
if [ $ftype = "Field3D" ]; then
cat <<EOF
        elif isinstance(self,Field3D) and isinstance(other,Field2D):
            fu.cobj=f$n((<Field3D?>self).cobj , (<Field2D?>other).cobj)
EOF
fi
cat <<EOF
        else:
            print("$n",type(self),type(other),isinstance(self,numbers.Number))
            return NotImplemented
        return fu

    def __r${n}__(self,lhs):
        fu=$ftype()
        if isinstance(lhs,float) or isinstance(lhs,int):
            fu.cobj=f$n(<double?>float(lhs),(<$ftype?>self).cobj)
EOF
if [ $ftype = "Field3D" ]; then
cat <<EOF
        elif isinstance(lhs,Field2D):
            fu.cobj=f$n((<Field2D?>lhs).cobj,(<Field3D?>self).cobj)
EOF
fi
cat <<EOF
        else:
            return NotImplemented
        return fu

    def __i${n}__(self,other):
        if isinstance(other,$ftype):
            fi$n((<$ftype?>self).cobj , (<$ftype?>other).cobj)
        elif isinstance(other,float) or isinstance(other,int):
            fi$n((<$ftype?>self).cobj , (<double?>float(other)))
EOF
if [ $ftype = "Field3D" ]; then
cat <<EOF
        elif isinstance(other,Field2D):
            fi$n((<Field3D?>self).cobj , (<Field2D?>other).cobj)
EOF
fi
cat <<EOF
        else:
            return NotImplemented
        return self

EOF

done
cat <<EOF
    def applyBoundary(self, boundary=None, time=None, region=None):
        """
        Set the boundaries of a $ftype. Only one of both arguments
        can be provided. If no value is provided, the default boundary
        is applied.

        Parameters
        ----------
        boundary : string
           The boundary to be set. Has to be a valid boundary type,
           e.g. "neumann".
        time : float
            The time to be used by the boundary, if time dependent
            boundary conditions are used.
        region : string
            The boundary region where the boundary condition is to be applied.
            Used only if 'boundary' option is set.
        """
        cdef c.string bndry
        cdef double _time
        if boundary is not None and time is not None:
            raise ValueError("Can only pass one of 'boundary' and 'time' options")
        if region is not None and boundary is None:
            raise ValueError("'region' has been passed but 'boundary' has not: region argument would be ignored.")
        if time is not None:
            _time = time
            self.cobj.applyBoundary(_time)
        elif boundary is not None:
            tmp=boundary.encode('ascii')
            bndry=tmp
            if region is None:
                self.cobj.applyBoundary(bndry)
            else:
                tmp=region.encode('ascii')
                region=tmp
                self.cobj.applyBoundary(region, bndry)
        else:
            self.cobj.applyBoundary()

    def __dealloc__(self):
        if self.isSelfOwned and self.cobj!=NULL:
            del self.cobj
            self.cobj=NULL

def create${ndim}D(string, Mesh msh=None,outloc="CELL_DEFAULT",time=0):
    """
    Returns a $ftype from the fieldfactory
    Parameters
    ----------
    string : string
        Expression to create. This can contain references to the options
    msh : Mesh
        the Mesh to use, defaults to the global mesh.
    outloc : string
        the cell location of the returned field
    time : float
         is the time

    Returns
    -------
    $ftype $ftypeFromObj $testthis $fdd
        the $ftype from the expression
    """
    checkInit()
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    if msh is None:
        msh=Mesh.getGlobal()
    cdef FieldFactory fact=msh.getFactory()
    cdef c.string str_=string.encode('ascii')
    return $ftypeFromObj(
        (<FieldFactory>fact).cobj.create${ndim}D(str_,<c.Options*>0,<c.Mesh*>0
                                           ,outloc_,time))


EOF
done
cat <<EOF

cdef extern from "helper.h":
    c.Mesh * c_get_global_mesh()
    void c_laplacian_solve(c.Laplacian *, c.Field3D *, c.Field3D*)
    c.Field3D c_Grad_perp_dot_Grad_perp(c.Field3D,c.Field3D);
    void c_mesh_normalise(c.Mesh* , double)
    c.Datafile * c_get_global_datafile()

cdef class Mesh:
    """
    Mesh class

    Contains information about geometry.
    It contains also the coordinates and is responsible for taking deriavtives.
    """
    cdef c.Mesh * cobj;
    cdef c.bool isGlobal
    cdef double isNormalised
    cdef FieldFactory factory
    cdef Coordinates _coords
    #factory=FieldFactory()
    def __init__(self, create=True, section=None, options=None):
        """
        Create a Mesh

        Parameter
        ---------
        create : bool
            Create the underling C++ object. Disabled probably only
            useful for internal usage. Use at own risk.
        section : string
            The section of the options which to read. If not given,
            default to the root section.
        options : Options
            The Option which to use. Can be specified together with
            \p section, in which case the subsection from the current
            Options object is used. If nether \p section nor \p
            options is given, the default section ([mesh]) fromt the
            global Options object is used.
        """
        checkInit()
        self.cobj=<c.Mesh*>0
        cdef c.string tmp
        cdef c.Options * opt = NULL
        self.isGlobal=False
        self.isNormalised=-1
        self.factory = FieldFactory()
        self._coords = None
        if create:
            if options:
                opt = (<Options?>options).cobj
            if section:
                if opt == NULL:
                    opt = c.Options.getRoot()
                for sec in section.split(":"):
                    tmp=sec.encode('ascii')
                    opt=opt.getSection(tmp)
            self.cobj = c.Mesh.create(opt)
            if self.cobj == NULL:
                raise MemoryError('Not enough memory, allocation failed.')
            self.cobj.load()
            self.cobj.setParallelTransform()

    @classmethod
    def getGlobal(cls):
        """
        Get the global Mesh object

        Returns
        -------
        Mesh
            The global instance
        """
        checkInit()
        msh = Mesh(create=False);
        msh.cobj = c_get_global_mesh();
        msh.isGlobal=True
        return msh

    def __dealloc__(self):
        if self.cobj and not self.isGlobal:
            del self.cobj

    cdef getFactory(self):
        """
        Get the FieldFactory of the mesh

        Returns
        -------
        FieldFactory
            The fieldfactory for the given mesh
        """
        if (<FieldFactory>self.factory).cobj == <c.FieldFactory*>0:
            (<FieldFactory?>self.factory).cobj = new c.FieldFactory(self.cobj,<c.Options*>0)
        return self.factory

    def normalise(self,double norm):
        """
        Normalise the mesh.

        Usefull if the Options are in SI units, but the simulation is written in Bohm units.
        Calling it multiple times will not change the mesh, if the normalisation is always the same.

        It calls mesh->dx/=norm etc. followed by a call to geometry().

        Parameters
        ----------
        norm : float
            The length with which to rescale
        """
        if self.isNormalised>0:
            t=norm
            norm=norm/self.isNormalised
            self.isNormalised=t
        c_mesh_normalise(self.cobj,norm)

    def communicate(self,*args):
        """
        Communicate (MPI) the boundaries of the Field3Ds with neighbours

        Parameters
        ----------
        args : Field3D
            Abitrary number of fields
        """
        cdef c.FieldGroup * fg = new c.FieldGroup()
        for f in args:
            fg.add((<Field3D?> f).cobj[0])
        self.cobj.communicate(fg[0])
        del fg
        return self

    def getCoordinates(self, loc=None):
        """
        Get the Coordinates object of this mesh
        """
        cdef benum.CELL_LOC loc_
        if loc is None:
            loc_= benum.resolve_cell_loc('CENTRE')
            if self._coords is None:
                self._coords = coordsFromObj(self.cobj.getCoordinates(loc_))
            return self._coords
        else:
            loc_= benum.resolve_cell_loc(loc)
            return coordsFromObj(self.cobj.getCoordinates(loc_))

cdef Coordinates coordsFromObj(c.Coordinates * obj):
    coords = Coordinates()
    coords.cobj = obj
    coords._setmembers()
    return coords
cdef class Coordinates:
    """
    Contains information about geometry, such as metric tensors
    """
    cdef c.Coordinates * cobj
    cdef public Field2D dx, dy
    cdef public double dz
    cdef public Field2D J
    cdef public Field2D Bxy
    cdef public Field2D g11, g22, g33, g12, g13, g23
    cdef public Field2D g_11, g_22, g_33, g_12, g_13, g_23
    cdef public Field2D G1_11, G1_22, G1_33, G1_12, G1_13, G1_23
    cdef public Field2D G2_11, G2_22, G2_33, G2_12, G2_13, G2_23
    cdef public Field2D G3_11, G3_22, G3_33, G3_12, G3_13, G3_23
    cdef public Field2D G1, G2, G3
    cdef public Field2D ShiftTorsion
    cdef public Field2D IntShiftTorsion

    def __init__(self):
        self.cobj = <c.Coordinates *>0

    def _setmembers(self):
EOF
for f in "dx" "dy" "J" "Bxy" "g11" "g22" "g33" "g12" "g13" "g23" "g_11" "g_22" "g_33" "g_12" "g_13" "g_23" "G1_11" "G1_22" "G1_33" "G1_12" "G1_13" "G1_23" "G2_11" "G2_22" "G2_33" "G2_12" "G2_13" "G2_23" "G3_11" "G3_22" "G3_33" "G3_12" "G3_13" "G3_23" "G1" "G2" "G3" "ShiftTorsion"
do
    echo "        self.${f} = f2dFromObj(self.cobj.${f})"
done
for f in "dz"
do
    echo "        self.${f} = self.cobj.${f}"
done
cat <<"EOF"

        # IntShiftTorsion is not always initialized. It should only be loaded
        # if localmesh->IncIntShear is true, but localmesh is a private member
        # of Coordinates which we cannot access here.
        #self.IntShiftTorsion = f2dFromObj(self.cobj.IntShiftTorsion)

cdef class Laplacian:
    """
    Laplacian inversion solver

    Compute the Laplacian inversion of objects.

    Equation solved is: d\\nabla^2_\\perp x + (1/c1)\\nabla_perp c2\\cdot\\nabla_\\perp x + ex\\nabla_x x + ez\\nabla_z x + a x = b
    """
    cdef c.Laplacian * cobj
    def __init__(self,section=None):
        """
        Initialiase a Laplacian solver

        Parameters
        ----------
        section : Options, optional
            The section from the Option tree to take the options from
        """
        checkInit()
        if section:
           self.cobj = c.Laplacian.create((<Options?>section).cobj)
        else:
           self.cobj = c.Laplacian.create(NULL)

    def solve(self,Field3D a, Field3D b):
        """
        Calculate the Laplacian inversion

        Parameters
        ----------
        x : Field3D
            Field to be inverted
        guess : Field3D
            initial guess for the inversion


        Returns
        -------
        Field3D
            the inversion of x, where guess is a guess to start with
        """
        return f3dFromObj(self.cobj.solve(a.cobj[0],b.cobj[0]))

    def setCoefs(self, **kwargs):
        """
        Set the coefficients for the Laplacian solver.
        The coefficients A, C, C1, C2, D, Ex and Ez can be passed as keyword arguments
        """
EOF
coeffs="A C C1 C2 D Ex Ez"
for coeff in $coeffs
do
cat <<EOF
        if '$coeff' in kwargs:
            self.setCoef$coeff(kwargs['$coeff'])
EOF
done
for coeff in $coeffs
do
    cat <<EOF

    def setCoef$coeff(self,Field3D $coeff):
        """
        Set the '$coeff' coefficient of the Laplacian solver

        Parameters
        ----------
        $coeff : Field3D
            Field to set as coefficient
        """
        self.cobj.setCoef$coeff($coeff.cobj[0])
EOF
done

cat <<"EOF"
cdef class FieldFactory:
    cdef c.FieldFactory * cobj
    def __init__(self):
        checkInit()
        cobj=< c.FieldFactory*>0
    def __dealloc__(self):
        if self.cobj != <c.FieldFactory*>0:
            del self.cobj
    # @classmethod
    # def fromPtr(cls,FieldFactory * cobj_):
    #     fu=cls()
    #     fu.cobj=cobj_
    #     return fu

cdef void callback(void * parameter, void * method) with gil:
    cdef double time = (<double*>parameter)[0]
    cdef c.string str_
    try:
        (<object?>method)(time)
    except BaseException, e:
        str__="Exception in Python callback: type:%s\nInfo:%s %s\n"%(str(type(e)),str(e),str(e.args))
        import traceback
        str__ += traceback.format_exc()
        str_=str__.encode('ascii')
        c.throw_BoutException(str_)


ctypedef void (*Method)(void *param)

cdef class PythonModelCallback:
    """Needed for callbacks from C++ to python"""
    cdef c.PythonModelCallback * cobj

    def __cinit__(self, method):
        # 'callback' :: The pattern/converter method to fire a Python
        #               object method from C typed infos
        # 'method'   :: The effective method passed by the Python user
        checkInit()
        self.cobj = new c.PythonModelCallback(callback, <void*>method)

    def __dealloc__(self):
        if self.thisptr:
            del self.thisptr

    cpdef void execute(self, parameter):
        # 'parameter' :: The parameter to be passed to the 'method'
        self.cobj.cy_execute(<void*>parameter)


cdef class PhysicsModelBase(object):
    """The PhysicsModelBase in python - better use the PhysicsModel class"""
    cdef c.PythonModel * cmodel
    cdef c.PythonModelCallback * callback
    cdef c.PythonModelCallback * callbackinit
    cdef c.bool _done_pyinit
    def __init__(self):
        checkInit()
        self.cmodel  = new c.PythonModel()
        self.callback= <c.PythonModelCallback*> 0
        self.callbackinit= <c.PythonModelCallback*> 0
        self._done_pyinit = False
    def solve(self):
        if self._done_pyinit == False:
            self._done_pyinit = True
            self.cmodel.pyinit()
        import sys
        sys.stdout.flush()
        self.cmodel.solve()

    def solve_for(self,**kwargs):
        if self._done_pyinit == False:
            self._done_pyinit = True
            self.cmodel.pyinit()
        cdef char * tmp
        cdef c.Field3D * f3d
        for key in kwargs:
            t2=str.encode(key)
            tmp=t2
            f3d=(<Field3D?>kwargs[key]).cobj
            self.cmodel.getSolver().add(f3d[0],tmp)

    def setRhs(self,rhs):
        """
        set the rhs function to be called

        Parameters
        ----------
        rhs : function
            Must not be a method, and must accept an double (time) as argument
        """
        if self.callback != <c.PythonModelCallback*>0:
            del self.callback
        self.callback = new c.PythonModelCallback(callback, <void*> rhs)
        self.cmodel.set_rhs_func(self.callback)

    def setInit(self,init):
        """
        set the init function to be called

        Parameters
        ----------
        init : function
            Must not be a method, and must accept an bool (restart) as argument
        """
        if self.callbackinit != <c.PythonModelCallback*>0:
            del self.callbackinit
        self.callbackinit = new c.PythonModelCallback(callback, <void*> init)
        self.cmodel.set_init_func(self.callbackinit)

    def __dealloc__(self):
        if self.cmodel != <c.PythonModel *> 0:
            self.cmodel.free()
            del self.cmodel
            del self.callback
            del self.callbackinit

class PhysicsModel(PhysicsModelBase):
    """The PhysicsModel base class for python"""
    def __init__(self):
        super(PhysicsModel,self).__init__()
        self._super_is_initialised=True
    def solve(self):
        """
        Call the solver.
        This makes sure that self.init(restart) and self.rhs(time) are called from the solver.
        """
        try:
            self._super_is_initialised
        except:
            raise RuntimeError("PhysicsModel is not initialized")
        def _rhs(time):
           self.rhs(time)
        self.myrhs=_rhs
        self.setRhs(self.myrhs)
        def _init(restart):
            self.init(restart)
        self.myinit=_init
        self.setInit(self.myinit)
        super(PhysicsModel,self).solve()
    def solve_for(self,*args,**kwargs):
        """
        Add Field3D's to be solved for.
        Need to pass as name=field - where name is the name that is
        used e.g. for the dump file and field is a Field3D

        Parameters
        ----------
        kwargs : dict
            Keys must be strings, and value of dict must be the Field3D which should be evolved.
        """
        try:
            self._super_is_initialised
        except:
            raise RuntimeError("PhysicsModel is not initialized")
        super(PhysicsModel,self).solve_for(*args,**kwargs)
    def init(self,restart):
        """
        This can be overwritten to do model specific initialization
        """
        pass

cdef extern from "bout.hxx":
    int BoutInitialise(int&, char **&)
    void BoutFinalise()

cdef extern from "boutcore_openmpi_compat.hxx":
    void PyMPI_OPENMPI_dlopen_libmpi()
    c.bool is_openmpi

_isInit=False
def init(args=[]):
    """
    Initialization function for the library.

    Parameters
    ----------
    args : list or string
        It accepts ether a list of strings, or a string that is split at the spaces.
        This is passed on to MPI and other libraries that BOUT++ initializes.
    """
    global _isInit
    if _isInit:
        raise RuntimeError("The BOUT++ library was already initialised - please call boutcore.init(args) only once")
    try:
        # python3 version
        if isinstance(args, str):
            args=args.split(" ")
    except:
        # fallback to python2
        if isinstance(args, basestring):
            args=args.split(" ")
    args.insert(0,"boutcore")
    cdef char **string_buf = <char **>malloc((len(args)+1) * sizeof(char*))
    fu=[]
    cdef char * tmp
    for i in range(len(args)):
        t2=str.encode(args[i])
        tmp=t2
        fu.append(tmp)
        string_buf[i]=<char*>fu[i]
    # terminate string_buf with a null pointer for OpenMPI, which requires this
    # because it iterates through 'argv' with a loop 'for (p = argv; *p; ++p)'
    string_buf[len(args)] = NULL
    cdef int fuu=len(args)
    if is_openmpi:
        PyMPI_OPENMPI_dlopen_libmpi()
    ret=BoutInitialise(fuu,string_buf)
    free(string_buf)
    if ret:
        BoutFinalise()
        raise RuntimeError("Failed to initialise the BOUT++ Library (Error code %d)"%ret)
    else:
        _isInit=True
    #atexit.register(finalise)

def finalise():
    """
    Finalize BOUT++ and also MPI.
    After this most objects and functions are not valid anymore.
    """
    checkInit()
    BoutFinalise()
    global _isInit
    _isInit=False

def checkInit():
    """
    Assert that boutcore has been initialized
    """
    global _isInit
    if not _isInit:
       raise RuntimeError("The BOUT++ library was not initialised - please call boutcore.init(args) first")

EOF

# note extra arguments to be passed to the function can be given as the third
# argument, but must start with a comma
dispatch_field_type1 () {
cat <<EOF
    if isinstance(${2}, Field3D):
        return f3dFromObj(c.${1}((<Field3D?>${2}).cobj[0]${3}))
    elif isinstance(${2}, Field2D):
        return f2dFromObj(c.${1}((<Field2D?>${2}).cobj[0]${3}))
    else:
        raise NotImplementedError("In ${1}: unexpected argument type '"+str(type(${2}))+"' - not supported (yet?).")
EOF
}

dispatch_field_type_to_BoutReal () {
cat <<EOF
    if isinstance(${2}, Field3D):
        return c.${1}((<Field3D?>${2}).cobj[0]${3})
    elif isinstance(${2}, Field2D):
        return c.${1}((<Field2D?>${2}).cobj[0]${3})
    else:
        raise NotImplementedError("In ${1}: unexpected argument type '"+str(type(${2}))+"' - not supported (yet?).")
EOF
}

# note extra arguments to be passed to the function can be given as the fourth
# argument, but must start with a comma
dispatch_field_type2 () {
cat <<EOF
    if isinstance(${2}, Field3D) and isinstance(${3}, Field3D):
        return f3dFromObj(c.${1}((<Field3D?>${2}).cobj[0], (<Field3D?>${3}).cobj[0]${4}))
    elif isinstance(${2}, Field2D) and isinstance(${3}, Field2D):
        return f2dFromObj(c.${1}((<Field2D?>${2}).cobj[0], (<Field2D?>${3}).cobj[0]${4}))
    else:
        raise NotImplementedError("In ${1}: unexpected argument types '"+str(type(${2}))+" and "+str(type(${3}))+"' - not supported (yet?).")
EOF
}

f_desc_f="field : Field3D Field2D
        The Field3D/Field2D object of which to calculate the derivative"
f_desc_vf="field: Field3D Field2D
        The Field3D/Field2D object of which to calculate the derivative
    velocity : Field3D Field2D
        The Field3D/Field2D object by which the field is advected"
fun1 () {
    cat <<EOF
def $DD($in1, outloc="CELL_DEFAULT", method="DIFF_DEFAULT", region="RGN_NOBNDRY"):
    """
    Compute the derivative $DD

    Parameters
    ---------
    $f_desc
    outloc : string
        The location where the derivative is expected. Defaults to the same as field.
    method : string
        The method to calculate the derivative.
    region : string
        The region for which to calculate the derivative

    Returns
    -------
    Field3D Field2D
        The computed $DD derivative
    """
    checkInit()
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    cdef benum.REGION region_=benum.resolve_region(region)
$(dispatch_field_type1 $DD $in1 "$args")
EOF
}
fun2 () {
    cat <<EOF
def $DD($in1, $in2, outloc="CELL_DEFAULT", method="DIFF_DEFAULT", region="RGN_NOBNDRY"):
    """
    Compute the derivative $DD

    Parameters
    ---------
    $f_desc
    outloc : string
        The location where the derivative is expected. Defaults to the same as field.
    method : string
        The method to calculate the derivative.
    region : string
        The region for which to calculate the derivative

    Returns
    -------
    Field3D Field2D
        The computed $DD derivative
    """
    checkInit()
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    cdef benum.DIFF_METHOD method_=benum.resolve_diff_method(method)
    cdef benum.REGION region_=benum.resolve_region(region)
$(dispatch_field_type2 $DD $in1 $in2 "$args")
EOF
}

for d in X Y Z
do
    for f in DDd D2Dd2
    do
        in1="field"
        args=", outloc_, method_, region_"
        DD=${f/d/$d}
        f_desc="$f_desc_f"
        fun1
    done
    for f in VDDd FDDd
    do
        in1="velocity"
        in2="field"
        args=", outloc_, method_, region_"
        DD=${f/d/$d}
        f_desc="$f_desc_vf"
        fun2
    done
done

for DD in Div_par Grad_par Grad2_par2
do
    in1="field"
    args=", outloc_, method_" # region argument is not implemented
    f_desc="$f_desc_f"
    fun1
done

for DD in Vpar_Grad_par Div_par_K_Grad_par Div_par_flux
do
    in1="velocity"
    in2="field"
    args=", outloc_, method_" # region argument is not implemented
    f_desc="$f_desc_vf"
    fun2
done

for DD in Laplace Laplace_par Laplace_perp
do
    cat <<EOF
def $DD(a, outloc="CELL_DEFAULT"):
    """
    Compute $DD

    Parameters
    ----------
    a : Field3D Field2D
        The Field3D/Field2D object of which to calculate the derivative
    outloc : str
        The location where the result should be calculated

    Returns
    -------
    Field3D Field2D
        The computed $DD
    """
    checkInit()
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
$(dispatch_field_type1 $DD a ", outloc_")

EOF
done

cat <<EOF
def Delp2(Field3D a, zsmooth=-1, outloc="CELL_DEFAULT"):
#    """Delp2(Field3D a, zsmooth=-1)"""
    checkInit()
    cdef benum.CELL_LOC outloc_= benum.resolve_cell_loc(outloc)
    return f3dFromObj(c.Delp2(a.cobj[0],float(zsmooth),outloc_))

def Grad_perp_dot_Grad_perp(Field3D a, Field3D b):
    """
    Parameters
    ----------
    a : Field3D
        The left field of the multiplication
    b : Field3D
        The right field of the multiplication

    Returns
    -------
    float
        the scalar product of the perpendicular gradient contributions
    """
    checkInit()
    return f3dFromObj(c_Grad_perp_dot_Grad_perp(a.cobj[0],b.cobj[0]))

def bracket(a, b, method="BRACKET_STD", outloc="CELL_DEFAULT"):
    """
    Calculate the poison bracket for Field3D a and Field3D b.

    Parameters
    ----------
    a : Field3D
        The left field in the bracket
    b : Field3D
        The right field in the bracket
    method : string
        The method to be used
    outloc : string
        The location of the calculated derivative

    Returns
    -------
    Field3D
        The bracket
    """
    checkInit()
    cdef benum.CELL_LOC outloc_=benum.resolve_cell_loc(outloc)
    cdef benum.BRACKET_METHOD method_=benum.resolve_bracket_method(method)
$(dispatch_field_type2 bracket a b ", method_, outloc_")

EOF
for fun in sqrt exp sin cos log abs
do
    cat <<EOF
def $fun(a):
    """
    Calculate $fun of a

    Parameters
    ----------
    a : Field3D Field2D
         The field for which to calculate $fun

    Returns
    -------
    Field3D Field2D
        $fun of a
    """
$(dispatch_field_type1 $fun a)

EOF
done

for fun in min max
do
cat <<EOF
def $fun(a):
    """
    Get the $fun

    Parameters
    ----------
    a : Field3D
        The field

    Returns
    -------
    float
        the $fun value of a
    """
$(dispatch_field_type_to_BoutReal $fun a)

EOF
done

cat <<EOF
def pow(a, exponent):
    """
    Returns a**e where a is a Field3D and e is a number

    Parameters
    ----------
    a : Field3D Field2D
        The field for which to calculate the power
    exponent : float
        The exponent

    Returns
    -------
    Field3D Field2D
        The a**exponent
    """
$(dispatch_field_type1 pow a ", float(exponent)")

def interp_to(f,location):
    """
    Interpolate a Field3D/Field2D to a given location

    Parameters
    ----------
    f3d : Field3D Field2D
        The field to interpolate
    location : string
        The location to which to interploate

    Returns
    -------
    Field3D Field2D
        the interpolated field
    """
    checkInit()
    cdef benum.CELL_LOC location_ = benum.resolve_cell_loc(location)
$(dispatch_field_type1 interp_to f ", location_")

def setOption(name, value, source="PyInterface", force=False):
    """
    Set an option in the global Options tree. Prefer
    'Options.set' to avoid unexpected results if several Option
    roots are avalaible.

    Parameters
    ----------
    name : string
        the name of the value to be set. Can be relative,
        e.g. 'mesh:ddx:first'.
    value : string
        the value to be set
    source : string
        The source of the change. Useful for keeping
        track of where what was set.
    force : bool
        If a value is overwritten, an exception is
        thrown. setting this to 'True' avoids the exception.
    """
    checkInit()
    root=Options('')
    root.set(name,value,source,force)

cdef class Options:
    """
    The Options class
    """
    cdef c.Options * cobj
    cdef c.bool isSelfOwned

    def __init__(self,name=""):
        checkInit()
        self.cobj = c.Options.getRoot()
        cdef c.string sec_
        for sec in name.split(":"):
            sec_=sec.encode('ascii')
            self.cobj=self.cobj.getSection(sec_)
        self.isSelfOwned=False

    @classmethod
    def fromFile(cls, file):
        """
        Create a new Options object by reading a file

        Parameters
        ----------
        file : string
            The path of the file to read

        Returns
        -------
        Options
            The Options object
        """
        checkInit()
        opt = Options("")
        opt.cobj = new c.Options()
        opt.isSelfOwned = True
        cdef char * file_
        file__=file.encode('ascii')
        file_=file__
        c.OptionsReader.getInstance().read(opt.cobj, file_)
        return opt


    def set(self,name,value,source="PyInterface", force=False):
        """
        Set an option

        Parameters
        ----------
        name : string
             the name of the value to be set. Can be relative,
             e.g. 'mesh:ddx:first'.
        value : string
            the value to be set
        source : string
            The source of the change. Useful for keeping
            track of where what was set.
        force : bool
            If a value is overwritten, an exception is
            thrown. setting this to 'True' avoids the exception.
        """
        cdef c.Options * opt=self.cobj
        cdef c.string sec_
        for sec in name.split(":")[:-1]:
            sec_=sec.encode('ascii')
            opt=opt.getSection(sec_)
        cdef c.string key = name.split(":")[-1].encode('ascii')
        cdef c.string value_ = value.encode('ascii')
        cdef c.string source_ = source.encode('ascii')
        opt.set(key,value_, source_, force)
        opt.cleanCache()
        return self

    def get(self,name,default):
        """
        Get an option

        Parameters
        ----------
        name : string
             the name of the value to get. Can be relative,
             e.g. 'mesh:ddx:first'.
        default : bool, string or float
            Depending on the type of the default, different things will be returned.
            Supported types are bool, string or float
        Returns
        -------
        bool, string or float
            See default for the type.
            The option that was read if available, otherwise default
        """
        cdef c.Options * opt=self.cobj
        cdef c.string sec_
        for sec in name.split(":")[:-1]:
            sec_=sec.encode('ascii')
            opt=opt.getSection(sec_)
        cdef c.string key = name.split(":")[-1].encode('ascii')
        import numbers

        cdef double ret_real=0
        cdef c.bool ret_bool=False
        cdef c.string default_
        cdef c.string ret_str

        if isinstance(default,bool):
            #print("isbool")
            opt.get(key,ret_bool, <c.bool> default)
            return ret_bool
        elif isinstance(default,numbers.Number):
            #print("isreal")
            opt.get(key,ret_real,<double> default)
            return ret_real
        else:
            #print("isstr")
            default_= str(default).encode('ascii')
            opt.get(key,ret_str, default_)
            return ret_str

cdef class Datafile:
     cdef c.Datafile * cobj
     def __init__(self):
         self.cobj = c_get_global_datafile()
     def add(self,save_repeat=False,**kwargs):
         for key in kwargs:
             self._add(kwargs[key],key,save_repeat)

     def _add(self,data,name,save_repeat):
         cdef char * tmp
         cdef double * dbl
         cdef c.Field3D * f3d
         t2=str.encode(name)
         tmp=t2
         # import numbers
         # if isinstance(data,int):
         #     #c_datafile_add_int(self.cobj,
         #     self.cobj.add(<int>data,tmp,<c.bool>save_repeat)
         # elif isinstance(data,numbers.Number):
         #     self.cobj.add(dbl,tmp,<c.bool>save_repeat)
         # el
         if isinstance(data,Field3D):
             f3d=(<Field3D>data).cobj
             self.cobj.add(f3d[0],tmp,<c.bool>save_repeat)
         else:
             raise TypeError("unsupported datatype")
     def write(self):
         self.cobj.write()



EOF

cat helper.py

bash resolve_enum_inv.pyx.in
